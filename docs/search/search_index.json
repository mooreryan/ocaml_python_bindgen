{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OCaml-Python Bindings Generator Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96 How to get started Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, check out some working examples on GitHub. Finally, there are some more (potentially) important details in the Rules and Miscellaneous sections of this site. If you have any questions or issues, please let me know about it on GitHub! Note: I try to keep this doc updated, but it may sometimes get out-of-sync with the latest pyml_bindgen . For the most up-to-date info, see the examples , tests , and dev tests , which are tested and kept up-to-date under CI. Installing Using Opam pyml_bindgen is available on Opam . You can install it in the normal way: $ opam install pyml_bindgen Installing from sources If you want to install from sources, e.g., to track the main branch or a development branch, but you do not want to install all the test and development packages, clone the repository, checkout the branch you want to follow and run opam install manually: $ git clone https://github.com/mooreryan/ocaml_python_bindgen.git $ git checkout dev $ opam install . This will save a lot of install time as it avoids some heavy packages. Development If instead, you want to work on pyml_bindgen development, will need to ensure you have the test dependencies, as well as a couple dependencies that are not included in the opam file ( core , core_bench , and bisect_ppx .) E.g., $ git clone https://github.com/mooreryan/ocaml_python_bindgen.git $ opam install . --deps-only --with-doc --with-test $ opam install core core_bench core_unix bisect_ppx $ dune build Quick start Note: You can find full examples in the examples directory on GitHub. One neat thing about the examples there is that you can see how to write Dune rules to automatically generate your pyml bindings. pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml If you want nicer formatting than that which is generated by pyml_bindgen , you can use ocamlformat . $ ocamlformat --enable-outside-detected-project lib.ml Next steps Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read. Additionally, you may want to check out this blog post introducing pyml_bindgen . License Software Copyright (c) 2021 - 2022 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms. Documentation Copyright (c) 2021 - 2022 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"pyml_bindgen"},{"location":"#ocaml-python-bindings-generator","text":"Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96","title":"OCaml-Python Bindings Generator"},{"location":"#how-to-get-started","text":"Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, check out some working examples on GitHub. Finally, there are some more (potentially) important details in the Rules and Miscellaneous sections of this site. If you have any questions or issues, please let me know about it on GitHub! Note: I try to keep this doc updated, but it may sometimes get out-of-sync with the latest pyml_bindgen . For the most up-to-date info, see the examples , tests , and dev tests , which are tested and kept up-to-date under CI.","title":"How to get started"},{"location":"#installing","text":"","title":"Installing"},{"location":"#using-opam","text":"pyml_bindgen is available on Opam . You can install it in the normal way: $ opam install pyml_bindgen","title":"Using Opam"},{"location":"#installing-from-sources","text":"If you want to install from sources, e.g., to track the main branch or a development branch, but you do not want to install all the test and development packages, clone the repository, checkout the branch you want to follow and run opam install manually: $ git clone https://github.com/mooreryan/ocaml_python_bindgen.git $ git checkout dev $ opam install . This will save a lot of install time as it avoids some heavy packages.","title":"Installing from sources"},{"location":"#development","text":"If instead, you want to work on pyml_bindgen development, will need to ensure you have the test dependencies, as well as a couple dependencies that are not included in the opam file ( core , core_bench , and bisect_ppx .) E.g., $ git clone https://github.com/mooreryan/ocaml_python_bindgen.git $ opam install . --deps-only --with-doc --with-test $ opam install core core_bench core_unix bisect_ppx $ dune build","title":"Development"},{"location":"#quick-start","text":"Note: You can find full examples in the examples directory on GitHub. One neat thing about the examples there is that you can see how to write Dune rules to automatically generate your pyml bindings. pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml If you want nicer formatting than that which is generated by pyml_bindgen , you can use ocamlformat . $ ocamlformat --enable-outside-detected-project lib.ml","title":"Quick start"},{"location":"#next-steps","text":"Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read. Additionally, you may want to check out this blog post introducing pyml_bindgen .","title":"Next steps"},{"location":"#license","text":"","title":"License"},{"location":"#software","text":"Copyright (c) 2021 - 2022 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms.","title":"Software"},{"location":"#documentation","text":"Copyright (c) 2021 - 2022 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"Documentation"},{"location":"attributes/","text":"Attributes & Properties Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a Rules The first and only function argument must be t . The return type can be any of the types mentioned earlier. Examples val x : t -> int val name : t -> string val price : t -> float","title":"Attributes & Properties"},{"location":"attributes/#attributes-properties","text":"Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a","title":"Attributes &amp; Properties"},{"location":"attributes/#rules","text":"The first and only function argument must be t . The return type can be any of the types mentioned earlier.","title":"Rules"},{"location":"attributes/#examples","text":"val x : t -> int val name : t -> string val price : t -> float","title":"Examples"},{"location":"auto-gen-bindings/","text":"Automatically Generating Bindings Sometimes it can be a bit of a pain to always have to run pyml_bindgen by hand. One way to avoid this is by adding a rule to your Dune file. For an example of this, check out the dune file in the quick start example on GitHub. It has lots of comments to show you how it is working.","title":"Auto-generating bindings"},{"location":"auto-gen-bindings/#automatically-generating-bindings","text":"Sometimes it can be a bit of a pain to always have to run pyml_bindgen by hand. One way to avoid this is by adding a rule to your Dune file. For an example of this, check out the dune file in the quick start example on GitHub. It has lots of comments to show you how it is working.","title":"Automatically Generating Bindings"},{"location":"cli-options/","text":"CLI Options For reference, here are the CLI opts: $ pyml_bindgen --help NAME pyml_bindgen - generate pyml bindings for a set of signatures SYNOPSIS pyml_bindgen [OPTION]... SIGNATURES PY_MODULE PY_CLASS DESCRIPTION Generate pyml bindings from OCaml signatures. ARGUMENTS PY_CLASS (required) Python class name PY_MODULE (required) Python module name SIGNATURES (required) Path to signatures OPTIONS -a ASSOCIATED_WITH, --associated-with=ASSOCIATED_WITH (absent=class) Are the Python functions associated with a class or just a module? ASSOCIATED_WITH must be either `class' or `module'. -c CAML_MODULE, --caml-module=CAML_MODULE Write full module and signature --help[=FMT] (default=auto) Show this help in format FMT. The value FMT must be one of `auto', `pager', `groff' or `plain'. With `auto', the format is `pager` or `plain' whenever the TERM env var is `dumb' or undefined. -r OF_PYO_RET_TYPE, --of-pyo-ret-type=OF_PYO_RET_TYPE (absent=option) Return type of the of_pyobject function. OF_PYO_RET_TYPE must be one of `no_check', `option' or `or_error'. --version Show version information. BUGS Please report any bugs or issues on GitHub. (https://github.com/mooreryan/pyml_bindgen/issues) SEE ALSO For full documentation, please see the GitHub page. (https://github.com/mooreryan/pyml_bindgen) AUTHORS Ryan M. Moore <https://orcid.org/0000-0003-3337-8184>","title":"CLI Options"},{"location":"cli-options/#cli-options","text":"For reference, here are the CLI opts: $ pyml_bindgen --help NAME pyml_bindgen - generate pyml bindings for a set of signatures SYNOPSIS pyml_bindgen [OPTION]... SIGNATURES PY_MODULE PY_CLASS DESCRIPTION Generate pyml bindings from OCaml signatures. ARGUMENTS PY_CLASS (required) Python class name PY_MODULE (required) Python module name SIGNATURES (required) Path to signatures OPTIONS -a ASSOCIATED_WITH, --associated-with=ASSOCIATED_WITH (absent=class) Are the Python functions associated with a class or just a module? ASSOCIATED_WITH must be either `class' or `module'. -c CAML_MODULE, --caml-module=CAML_MODULE Write full module and signature --help[=FMT] (default=auto) Show this help in format FMT. The value FMT must be one of `auto', `pager', `groff' or `plain'. With `auto', the format is `pager` or `plain' whenever the TERM env var is `dumb' or undefined. -r OF_PYO_RET_TYPE, --of-pyo-ret-type=OF_PYO_RET_TYPE (absent=option) Return type of the of_pyobject function. OF_PYO_RET_TYPE must be one of `no_check', `option' or `or_error'. --version Show version information. BUGS Please report any bugs or issues on GitHub. (https://github.com/mooreryan/pyml_bindgen/issues) SEE ALSO For full documentation, please see the GitHub page. (https://github.com/mooreryan/pyml_bindgen) AUTHORS Ryan M. Moore <https://orcid.org/0000-0003-3337-8184>","title":"CLI Options"},{"location":"dictionaries-2/","text":"Handling Python Dictionaries 2 In the first article about handling Python dictionaries, we wrote a custom Dict module to handle string => string dictionaries. Sometimes when you're binding a large Python project, there will be many different kinds of dictionaries that you need to bind. Rather than write out a module for each key-value type combination we need, this time let's write some functors to help us cut down on the boilerplate. Note: This isn't an introduction to functors, so I won't be explaining too many of the functor specific details! Python code First let's check out the Python code we're going to be binding. silly.py class Inventory: def __init__(self, items): self.d = items def incr(self, item): self.d[item] += 1 def decr(self, item): self.d[item] -= 1 class WeirdDict: def __init__(self, d): self.d = d def add(self, k, v): self.d[k] = v def get(self, k): return self.d[k] As you see, both of these classes are polymorphic with respect to the types they can work with. But for this example, we are going to constrain there types. We will say Inventory is a mapping from strings to integers, and WeirdDict is a mapping from integers to string lists. Here are the value specifications. inventory_val_specs.txt val __init__ : items:String_int_dict.t -> unit -> t option val d : t -> String_int_dict.t option val incr : t -> item:string -> unit -> unit val decr : t -> item:string -> unit -> unit weird_dict_val_specs.txt val __init__ : d:Int_string_list_dict.t -> unit -> t option val d : t -> Int_string_list_dict.t option val add : t -> k:Int.t -> v:String_list.t -> unit -> unit val get : t -> k:Int.t -> unit -> String_list.t A couple notable things here. First, we are putting in some modules that haven't yet been defined: String_int_dict , Int_string_list_dict , and String_list . We will get to them below. You may think, yuck, I don't want to have to deal with a custom type String_list instead of using string list . Don't worry, it will all work out nicely :) Second, we're going to be checking the Python class of everything that goes through an of_pyobject function. (Both in the functors we write, and in the pyml_bindgen app using -r option .) Most of the previous examples haven't bothered with checking the return types to keep things simple. Since this example is more involved anyway, let's go ahead and check the types! Module types & functors Now let's write some functors! Note that I will be making use of features from Base and ppx_jane in this example. Put the code in this section into a file called pyobjectable.ml . Don't forget to put open! Base at the top! Module types First we define a module type called Pyobjectable.S ( S for signature), that has a type t and two functions, of_pyobject and to_pyobject . Note on naming: Pyobjectable => Something that can be turned into a pyobject and back. It's named this way to match the Base naming scheme. module type S = sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject end We will mint another module type that is specific to lists. module type S_list = sig include module type of struct include List end type element type t = element list val of_pyobject : Pytypes.pyobject -> element list val to_pyobject : element list -> Pytypes.pyobject end Next, a module type to describe things that can be used as keys in our dictionaries. module type S_dict_key = sig type t [@@deriving hash, sexp] include Comparable.S with type t := t include S with type t := t end The hash , sexp derives plus including Comparable.S allow us to use S_dict_key as a key in both Base.Map and Base.Hashtbl modules. And of course, we also include S because we want it to be pyobjectable. Finally, we make a Pydict module type. This type will be helpful when converting values into and out of pyobjects . module type Pydict = sig type t type key type value type map type hashtbl val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val of_alist : (key * value) list -> t val to_alist : t -> (key * value) list val of_map : map -> t val to_map : t -> map val of_hashtbl : hashtbl -> t val to_hashtbl : t -> hashtbl end In this case, we're saying that we want Pydicts to know how to convert to and from pyobjects , association lists, maps , and hashtbls . Notice how we return t option in the of_pyobject function. This way we can be (a little more) sure that the type is correct. I say a little more because we won't be checking that the types of the keys and values inside the Python dictionary are what we say they are, just that the object is in fact, a Python dictionary. Functors Now let's write two functors that use the above types. First, a functor to make pyobjectable lists ( S_list ): module Make_list (Element : S) : S_list with type element := Element.t = struct include List type t = Element.t list let of_pyobject pyo = Py.List.to_list_map Element.of_pyobject pyo let to_pyobject l = Py.List.of_list_map Element.to_pyobject l end Next, a functor to make Pydicts . module Make_pydict (Key : S_dict_key) (Value : S) : Pydict with type key := Key.t with type value := Value.t with type map := Value.t Map.M(Key).t with type hashtbl := Value.t Hashtbl.M(Key).t = struct type t = Pytypes.pyobject let of_pyobject x = if Py.Dict.check x then Some x else None let to_pyobject x = x let of_alist = Py.Dict.of_bindings_map Key.to_pyobject Value.to_pyobject let to_alist = Py.Dict.to_bindings_map Key.of_pyobject Value.of_pyobject let of_map map = of_alist @@ Map.to_alist map let to_map t = Map.of_alist_exn (module Key) @@ to_alist t let of_hashtbl ht = of_alist @@ Hashtbl.to_alist ht let to_hashtbl t = Hashtbl.of_alist_exn (module Key) @@ to_alist t end Making the needed modules Now that we have our functors, let's make the modules that we specified in the value specs above. Put the following in a file called extensions.ml open! Base module Int = struct include Int let of_pyobject pyo = Py.Int.to_int pyo let to_pyobject i = Py.Int.of_int i end module String = struct include String let of_pyobject pyo = Py.String.to_string pyo let to_pyobject i = Py.String.of_string i end module String_list = Pyobjectable.Make_list (String) module String_int_dict = Pyobjectable.Make_pydict (String) (Int) module Int_string_list_dict = Pyobjectable.Make_pydict (Int) (String_list) A couple of notes here: We're extending Int and String modules so that they will be Pyobjectable . This code we need to write by hand because each basic OCaml type has its own special way of converting to and from a pyobject . You will note that we didn't have to do anything special to ensure that Int was okay to use as a S_dict_key . Since we're using Base, and given the way we wrote the functor, it's all taken care of. String_list is a \"special\" list that knows how to turn string list values to and from pyobjects . Finally, we use our extended Int and String along with String_list to make the *_dict modules that we put in our val specs. Running pyml_bindgen Now that we have all our machinery set up, we're ready to run pyml_bindgen . $ printf \"open Extensions\\n\" > lib.ml $ pyml_bindgen inventory_val_specs.txt silly Inventory --caml-module Inventory \\ | ocamlformat --enable --name=a.ml - >> lib.ml $ printf \"\\n\" >> lib.ml $ pyml_bindgen weird_dict_val_specs.txt silly WeirdDict --caml-module Weird_dict \\ | ocamlformat --enable --name=a.ml - >> lib.ml I interspersed some extra code and spaces between the pyml_bindgen calls using printf . If you need more explanation of the pyml_bindgen options used above, see here . Set up Dune project & run it Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open! Stdio open! Extensions open! Lib let () = Py.initialize () let items = String_int_dict.of_alist [ (\"apple\", 10); (\"pie\", 3) ] let items' = String_int_dict.to_alist items let () = print_s @@ [%sexp_of: (string * int) list] @@ items' let inventory = Option.value_exn (Inventory.__init__ ~items ()) let () = Inventory.incr inventory ~item:\"apple\" () let () = Inventory.decr inventory ~item:\"pie\" () let () = let d = Option.value_exn (Inventory.d inventory) in print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist d (* This is the WRONG WAY to do it... *) let () = let pyo = Inventory.to_pyobject inventory in match String_int_dict.of_pyobject pyo with | Some pyo' -> print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist pyo' | None -> print_endline \"Couldn't convert the pyobject to String_int_dict! Moving on...\" (* Now for the weird dict *) let d = Int_string_list_dict.of_alist [ (1, [ \"apple\"; \"pie\" ]); (2, [ \"is\"; \"good\" ]) ] let weird = Option.value_exn (Weird_dict.__init__ ~d ()) let () = Weird_dict.add weird ~k:3 ~v:[ \"peach\"; \"cobbler\" ] () let () = assert ( List.equal String.equal [ \"peach\"; \"cobbler\" ] (Weird_dict.get weird ~k:3 ())) let () = let d = Option.value_exn (Weird_dict.d weird) in let alist = Int_string_list_dict.to_alist d in print_s @@ [%sexp_of: (int * string list) list] @@ alist Check out how we can use a regular string list for the v argument to Weird_dict.add even though we specified the type as String_list.t . Same thing goes for the return type of the get function. It \"just works\" because of the way we set up the functors earlier. Nice! Run it, and if all goes well, you should see something like this: $ dune exec ./run.exe ((apple 10) (pie 3)) ((apple 11) (pie 2)) Couldn't convert the pyobject to String_int_dict! Moving on... ((1 (apple pie)) (2 (is good)) (3 (peach cobbler))) Wrap-up In this tutorial, we built upon the first dictionary tutorial by using functors to avoid having to write the dictionary helper modules by hand. While you might think functors are overkill for this little example, there are real Python projects that have lots of different dictionaries that you need to use. For example, spaCy has more than 10 different kinds of dictionaries to bind! Writing all that by hand will get tedious :)","title":"Handling Dictionaries 2"},{"location":"dictionaries-2/#handling-python-dictionaries-2","text":"In the first article about handling Python dictionaries, we wrote a custom Dict module to handle string => string dictionaries. Sometimes when you're binding a large Python project, there will be many different kinds of dictionaries that you need to bind. Rather than write out a module for each key-value type combination we need, this time let's write some functors to help us cut down on the boilerplate. Note: This isn't an introduction to functors, so I won't be explaining too many of the functor specific details!","title":"Handling Python Dictionaries 2"},{"location":"dictionaries-2/#python-code","text":"First let's check out the Python code we're going to be binding. silly.py class Inventory: def __init__(self, items): self.d = items def incr(self, item): self.d[item] += 1 def decr(self, item): self.d[item] -= 1 class WeirdDict: def __init__(self, d): self.d = d def add(self, k, v): self.d[k] = v def get(self, k): return self.d[k] As you see, both of these classes are polymorphic with respect to the types they can work with. But for this example, we are going to constrain there types. We will say Inventory is a mapping from strings to integers, and WeirdDict is a mapping from integers to string lists. Here are the value specifications. inventory_val_specs.txt val __init__ : items:String_int_dict.t -> unit -> t option val d : t -> String_int_dict.t option val incr : t -> item:string -> unit -> unit val decr : t -> item:string -> unit -> unit weird_dict_val_specs.txt val __init__ : d:Int_string_list_dict.t -> unit -> t option val d : t -> Int_string_list_dict.t option val add : t -> k:Int.t -> v:String_list.t -> unit -> unit val get : t -> k:Int.t -> unit -> String_list.t A couple notable things here. First, we are putting in some modules that haven't yet been defined: String_int_dict , Int_string_list_dict , and String_list . We will get to them below. You may think, yuck, I don't want to have to deal with a custom type String_list instead of using string list . Don't worry, it will all work out nicely :) Second, we're going to be checking the Python class of everything that goes through an of_pyobject function. (Both in the functors we write, and in the pyml_bindgen app using -r option .) Most of the previous examples haven't bothered with checking the return types to keep things simple. Since this example is more involved anyway, let's go ahead and check the types!","title":"Python code"},{"location":"dictionaries-2/#module-types-functors","text":"Now let's write some functors! Note that I will be making use of features from Base and ppx_jane in this example. Put the code in this section into a file called pyobjectable.ml . Don't forget to put open! Base at the top!","title":"Module types &amp; functors"},{"location":"dictionaries-2/#module-types","text":"First we define a module type called Pyobjectable.S ( S for signature), that has a type t and two functions, of_pyobject and to_pyobject . Note on naming: Pyobjectable => Something that can be turned into a pyobject and back. It's named this way to match the Base naming scheme. module type S = sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject end We will mint another module type that is specific to lists. module type S_list = sig include module type of struct include List end type element type t = element list val of_pyobject : Pytypes.pyobject -> element list val to_pyobject : element list -> Pytypes.pyobject end Next, a module type to describe things that can be used as keys in our dictionaries. module type S_dict_key = sig type t [@@deriving hash, sexp] include Comparable.S with type t := t include S with type t := t end The hash , sexp derives plus including Comparable.S allow us to use S_dict_key as a key in both Base.Map and Base.Hashtbl modules. And of course, we also include S because we want it to be pyobjectable. Finally, we make a Pydict module type. This type will be helpful when converting values into and out of pyobjects . module type Pydict = sig type t type key type value type map type hashtbl val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val of_alist : (key * value) list -> t val to_alist : t -> (key * value) list val of_map : map -> t val to_map : t -> map val of_hashtbl : hashtbl -> t val to_hashtbl : t -> hashtbl end In this case, we're saying that we want Pydicts to know how to convert to and from pyobjects , association lists, maps , and hashtbls . Notice how we return t option in the of_pyobject function. This way we can be (a little more) sure that the type is correct. I say a little more because we won't be checking that the types of the keys and values inside the Python dictionary are what we say they are, just that the object is in fact, a Python dictionary.","title":"Module types"},{"location":"dictionaries-2/#functors","text":"Now let's write two functors that use the above types. First, a functor to make pyobjectable lists ( S_list ): module Make_list (Element : S) : S_list with type element := Element.t = struct include List type t = Element.t list let of_pyobject pyo = Py.List.to_list_map Element.of_pyobject pyo let to_pyobject l = Py.List.of_list_map Element.to_pyobject l end Next, a functor to make Pydicts . module Make_pydict (Key : S_dict_key) (Value : S) : Pydict with type key := Key.t with type value := Value.t with type map := Value.t Map.M(Key).t with type hashtbl := Value.t Hashtbl.M(Key).t = struct type t = Pytypes.pyobject let of_pyobject x = if Py.Dict.check x then Some x else None let to_pyobject x = x let of_alist = Py.Dict.of_bindings_map Key.to_pyobject Value.to_pyobject let to_alist = Py.Dict.to_bindings_map Key.of_pyobject Value.of_pyobject let of_map map = of_alist @@ Map.to_alist map let to_map t = Map.of_alist_exn (module Key) @@ to_alist t let of_hashtbl ht = of_alist @@ Hashtbl.to_alist ht let to_hashtbl t = Hashtbl.of_alist_exn (module Key) @@ to_alist t end","title":"Functors"},{"location":"dictionaries-2/#making-the-needed-modules","text":"Now that we have our functors, let's make the modules that we specified in the value specs above. Put the following in a file called extensions.ml open! Base module Int = struct include Int let of_pyobject pyo = Py.Int.to_int pyo let to_pyobject i = Py.Int.of_int i end module String = struct include String let of_pyobject pyo = Py.String.to_string pyo let to_pyobject i = Py.String.of_string i end module String_list = Pyobjectable.Make_list (String) module String_int_dict = Pyobjectable.Make_pydict (String) (Int) module Int_string_list_dict = Pyobjectable.Make_pydict (Int) (String_list) A couple of notes here: We're extending Int and String modules so that they will be Pyobjectable . This code we need to write by hand because each basic OCaml type has its own special way of converting to and from a pyobject . You will note that we didn't have to do anything special to ensure that Int was okay to use as a S_dict_key . Since we're using Base, and given the way we wrote the functor, it's all taken care of. String_list is a \"special\" list that knows how to turn string list values to and from pyobjects . Finally, we use our extended Int and String along with String_list to make the *_dict modules that we put in our val specs.","title":"Making the needed modules"},{"location":"dictionaries-2/#running-pyml_bindgen","text":"Now that we have all our machinery set up, we're ready to run pyml_bindgen . $ printf \"open Extensions\\n\" > lib.ml $ pyml_bindgen inventory_val_specs.txt silly Inventory --caml-module Inventory \\ | ocamlformat --enable --name=a.ml - >> lib.ml $ printf \"\\n\" >> lib.ml $ pyml_bindgen weird_dict_val_specs.txt silly WeirdDict --caml-module Weird_dict \\ | ocamlformat --enable --name=a.ml - >> lib.ml I interspersed some extra code and spaces between the pyml_bindgen calls using printf . If you need more explanation of the pyml_bindgen options used above, see here .","title":"Running pyml_bindgen"},{"location":"dictionaries-2/#set-up-dune-project-run-it","text":"Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open! Stdio open! Extensions open! Lib let () = Py.initialize () let items = String_int_dict.of_alist [ (\"apple\", 10); (\"pie\", 3) ] let items' = String_int_dict.to_alist items let () = print_s @@ [%sexp_of: (string * int) list] @@ items' let inventory = Option.value_exn (Inventory.__init__ ~items ()) let () = Inventory.incr inventory ~item:\"apple\" () let () = Inventory.decr inventory ~item:\"pie\" () let () = let d = Option.value_exn (Inventory.d inventory) in print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist d (* This is the WRONG WAY to do it... *) let () = let pyo = Inventory.to_pyobject inventory in match String_int_dict.of_pyobject pyo with | Some pyo' -> print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist pyo' | None -> print_endline \"Couldn't convert the pyobject to String_int_dict! Moving on...\" (* Now for the weird dict *) let d = Int_string_list_dict.of_alist [ (1, [ \"apple\"; \"pie\" ]); (2, [ \"is\"; \"good\" ]) ] let weird = Option.value_exn (Weird_dict.__init__ ~d ()) let () = Weird_dict.add weird ~k:3 ~v:[ \"peach\"; \"cobbler\" ] () let () = assert ( List.equal String.equal [ \"peach\"; \"cobbler\" ] (Weird_dict.get weird ~k:3 ())) let () = let d = Option.value_exn (Weird_dict.d weird) in let alist = Int_string_list_dict.to_alist d in print_s @@ [%sexp_of: (int * string list) list] @@ alist Check out how we can use a regular string list for the v argument to Weird_dict.add even though we specified the type as String_list.t . Same thing goes for the return type of the get function. It \"just works\" because of the way we set up the functors earlier. Nice! Run it, and if all goes well, you should see something like this: $ dune exec ./run.exe ((apple 10) (pie 3)) ((apple 11) (pie 2)) Couldn't convert the pyobject to String_int_dict! Moving on... ((1 (apple pie)) (2 (is good)) (3 (peach cobbler)))","title":"Set up Dune project &amp; run it"},{"location":"dictionaries-2/#wrap-up","text":"In this tutorial, we built upon the first dictionary tutorial by using functors to avoid having to write the dictionary helper modules by hand. While you might think functors are overkill for this little example, there are real Python projects that have lots of different dictionaries that you need to use. For example, spaCy has more than 10 different kinds of dictionaries to bind! Writing all that by hand will get tedious :)","title":"Wrap-up"},{"location":"dictionaries/","text":"Handling Python Dictionaries Note: This is a simpler way to handle dictionaries. For a more general, but more complicated way, see here . Let's see how to handle Python Dictionaries . For now, you need to define a module that has a couple of functions. For now, we will call it Dict . You can use a signature or mli file if you want, but to keep it simple, we will leave it out for now. Stick the following code in a file called dict.ml type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x Technically, that would be all you need, but it's not very easy to work with...you would have to create all your own pyobjects by hand. Yuck! The next thing you need is to decide what kind of interface you want your Dict.t to have. By that I just mean that it would be nice to have a convenient way to get standard \"dictionary-like\" types into Dict.t . In this tutorial, we will look at three: an association list, and Base's Map and Hashtbl . Of course, you may want to use something different, and that will work just fine after you see how to do it. Write val specs But first we should look at the Python code we are planning to bind. silly_map.py def add(d, k, v): d[k] = v def get(d, k): return d[k] Just two functions to define a weird little map module: add and get , both of which take a dictionary as their first argument. The Python dictionary can have pretty much any types for keys and values, but we are going to use it as a string => string map. You should choose whatever types make sense for your particular use case. Here are the value specs to bind these functions. val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string Generate bindings Now, let's generate our library code. $ pyml_bindgen val_specs.txt silly_map NA \\ --caml-module=Silly_map -a module -r no_check \\ | ocamlformat --enable - --name=x.ml \\ > lib.ml See that weird NA in the command? That's because you currently have to pass in a Python class name, even if you are binding module functions. The generated OCaml module will be Silly_map . The other flags specify that we want to bind module associated code and not code associated with a class ( -a module ), and that we don't want to check the results of any converting code ( -r no_check ). *Note: For more info on pyml_bindgen CLI args, see here . Here's what the generated code looks like: module Silly_map : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"silly_map\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let add ~d ~k ~v () = let callable = Py.Module.get (import_module ()) \"add\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k); Some (\"v\", Py.String.of_string v); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let get ~d ~k () = let callable = Py.Module.get (import_module ()) \"get\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k) ] in Py.String.to_string @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Finish the Dict module Okay, now that we know a little more about the Python code and our desired interface for the Silly_map module, let's return to the Dict module and fill it out. Here's the whole thing. Jump down for some explanations. open! Base type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x let empty () = Py.Dict.create () let of_alist x = Py.Dict.of_bindings_map Py.String.of_string Py.String.of_string x let to_alist x = Py.Dict.to_bindings_map Py.String.to_string Py.String.to_string x let of_map x = of_alist @@ Map.to_alist x let to_map x = Map.of_alist_exn (module String) @@ to_alist x let of_hashtbl x = of_alist @@ Hashtbl.to_alist x let to_hashtbl x = Hashtbl.of_alist_exn (module String) @@ to_alist x let print_endline x = Stdio.print_endline @@ Sexp.to_string_hum @@ [%sexp_of: (string * string) list] @@ to_alist x of_alist and to_alist let us connect the Dict module with association lists. The Py.Dict.of_bindings_map function takes two functions used to convert OCaml values to Python values, and the association list. In this case, we're passing in strings, so we use Py.String.of_string to convert an OCaml string to a Pytypes.pyobject . The to_bindings_map works in an analogous way. Note: For more info on writing pyml bindings, check out the py.mli signature file. Next, the of/to_map and of/to_hashtbl functions are pretty simple. Both Map and Hashtbl modules have a of/to_alist functions. So, we just call the function to convert to/from an association list, then call the matching Dict.of/to_alist function. Finally, I threw in a printing function that uses sexp_of to convert the alist to a sexp, then print it. Setup Dune project & run Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open Lib open Stdio let () = Py.initialize () let d = Dict.empty () let () = Silly_map.add ~d ~k:\"apple\" ~v:\"pie\" () let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = print_endline @@ Silly_map.get ~d ~k:\"apple\" () let () = print_endline @@ Silly_map.get ~d ~k:\"is\" () (* Another example. *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let () = print_endline @@ Silly_map.get ~d:(Dict.of_alist [ (\"apple\", \"pie\") ]) ~k:\"apple\" () (* Base.Map *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let m = Map.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_map m let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d (* Base.Hashtbl *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let ht = Hashtbl.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_hashtbl ht let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d Run it like so: $ dune exec ./run.exe If all goes well, you should see some zany output like this: pie good ~~~~~~~~~~~~~~~~~~~~~~~~~~ pie ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good)) ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good)) Wrap-up In this tutorial, we went over a couple of ways to handle Python Dictionaries. A lot of times, you will need to pass a dictionary to a Python function or return one from a Python function. Hopefully, you have a good idea of how to do this now!","title":"Handling Dictionaries"},{"location":"dictionaries/#handling-python-dictionaries","text":"Note: This is a simpler way to handle dictionaries. For a more general, but more complicated way, see here . Let's see how to handle Python Dictionaries . For now, you need to define a module that has a couple of functions. For now, we will call it Dict . You can use a signature or mli file if you want, but to keep it simple, we will leave it out for now. Stick the following code in a file called dict.ml type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x Technically, that would be all you need, but it's not very easy to work with...you would have to create all your own pyobjects by hand. Yuck! The next thing you need is to decide what kind of interface you want your Dict.t to have. By that I just mean that it would be nice to have a convenient way to get standard \"dictionary-like\" types into Dict.t . In this tutorial, we will look at three: an association list, and Base's Map and Hashtbl . Of course, you may want to use something different, and that will work just fine after you see how to do it.","title":"Handling Python Dictionaries"},{"location":"dictionaries/#write-val-specs","text":"But first we should look at the Python code we are planning to bind. silly_map.py def add(d, k, v): d[k] = v def get(d, k): return d[k] Just two functions to define a weird little map module: add and get , both of which take a dictionary as their first argument. The Python dictionary can have pretty much any types for keys and values, but we are going to use it as a string => string map. You should choose whatever types make sense for your particular use case. Here are the value specs to bind these functions. val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string","title":"Write val specs"},{"location":"dictionaries/#generate-bindings","text":"Now, let's generate our library code. $ pyml_bindgen val_specs.txt silly_map NA \\ --caml-module=Silly_map -a module -r no_check \\ | ocamlformat --enable - --name=x.ml \\ > lib.ml See that weird NA in the command? That's because you currently have to pass in a Python class name, even if you are binding module functions. The generated OCaml module will be Silly_map . The other flags specify that we want to bind module associated code and not code associated with a class ( -a module ), and that we don't want to check the results of any converting code ( -r no_check ). *Note: For more info on pyml_bindgen CLI args, see here . Here's what the generated code looks like: module Silly_map : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"silly_map\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let add ~d ~k ~v () = let callable = Py.Module.get (import_module ()) \"add\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k); Some (\"v\", Py.String.of_string v); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let get ~d ~k () = let callable = Py.Module.get (import_module ()) \"get\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k) ] in Py.String.to_string @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Generate bindings"},{"location":"dictionaries/#finish-the-dict-module","text":"Okay, now that we know a little more about the Python code and our desired interface for the Silly_map module, let's return to the Dict module and fill it out. Here's the whole thing. Jump down for some explanations. open! Base type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x let empty () = Py.Dict.create () let of_alist x = Py.Dict.of_bindings_map Py.String.of_string Py.String.of_string x let to_alist x = Py.Dict.to_bindings_map Py.String.to_string Py.String.to_string x let of_map x = of_alist @@ Map.to_alist x let to_map x = Map.of_alist_exn (module String) @@ to_alist x let of_hashtbl x = of_alist @@ Hashtbl.to_alist x let to_hashtbl x = Hashtbl.of_alist_exn (module String) @@ to_alist x let print_endline x = Stdio.print_endline @@ Sexp.to_string_hum @@ [%sexp_of: (string * string) list] @@ to_alist x of_alist and to_alist let us connect the Dict module with association lists. The Py.Dict.of_bindings_map function takes two functions used to convert OCaml values to Python values, and the association list. In this case, we're passing in strings, so we use Py.String.of_string to convert an OCaml string to a Pytypes.pyobject . The to_bindings_map works in an analogous way. Note: For more info on writing pyml bindings, check out the py.mli signature file. Next, the of/to_map and of/to_hashtbl functions are pretty simple. Both Map and Hashtbl modules have a of/to_alist functions. So, we just call the function to convert to/from an association list, then call the matching Dict.of/to_alist function. Finally, I threw in a printing function that uses sexp_of to convert the alist to a sexp, then print it.","title":"Finish the Dict module"},{"location":"dictionaries/#setup-dune-project-run","text":"Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open Lib open Stdio let () = Py.initialize () let d = Dict.empty () let () = Silly_map.add ~d ~k:\"apple\" ~v:\"pie\" () let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = print_endline @@ Silly_map.get ~d ~k:\"apple\" () let () = print_endline @@ Silly_map.get ~d ~k:\"is\" () (* Another example. *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let () = print_endline @@ Silly_map.get ~d:(Dict.of_alist [ (\"apple\", \"pie\") ]) ~k:\"apple\" () (* Base.Map *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let m = Map.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_map m let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d (* Base.Hashtbl *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let ht = Hashtbl.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_hashtbl ht let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d Run it like so: $ dune exec ./run.exe If all goes well, you should see some zany output like this: pie good ~~~~~~~~~~~~~~~~~~~~~~~~~~ pie ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good)) ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good))","title":"Setup Dune project &amp; run"},{"location":"dictionaries/#wrap-up","text":"In this tutorial, we went over a couple of ways to handle Python Dictionaries. A lot of times, you will need to pass a dictionary to a Python function or return one from a Python function. Hopefully, you have a good idea of how to do this now!","title":"Wrap-up"},{"location":"embedding-python/","text":"Embedding Python Source Code If you import modules in Python code, Python needs to be able to actually find these modules. One way is to \"install\" the Python module you want with say, pip. E.g., pip install whatever . If you're working on a Python module along with your OCaml code, you probably don't want to do this. Rather, you probably want to set the PYTHONPATH environment variable to the location of your Python modules. (You can find an example an detailed explanation of that in the importing modules example on GitHub.) The third option is to embed the Python code directly into the generated OCaml module. The --embed-python-source CLI option lets you do this. Basically, you just provide the path to the Python module you want to embed to that option, and it will all work out for you. This way you don't have to have your user's worry about setting the PYTHONPATH properly. To see it in action, check out the example on GitHub.","title":"Embedding Python source"},{"location":"embedding-python/#embedding-python-source-code","text":"If you import modules in Python code, Python needs to be able to actually find these modules. One way is to \"install\" the Python module you want with say, pip. E.g., pip install whatever . If you're working on a Python module along with your OCaml code, you probably don't want to do this. Rather, you probably want to set the PYTHONPATH environment variable to the location of your Python modules. (You can find an example an detailed explanation of that in the importing modules example on GitHub.) The third option is to embed the Python code directly into the generated OCaml module. The --embed-python-source CLI option lets you do this. Basically, you just provide the path to the Python module you want to embed to that option, and it will all work out for you. This way you don't have to have your user's worry about setting the PYTHONPATH properly. To see it in action, check out the example on GitHub.","title":"Embedding Python Source Code"},{"location":"examples/","text":"Lots of Examples You can find a lot of examples on GitHub . These examples are particularly cool because they show you how to use Dune rules to generate bindings automatically. Also, they are tested along with the rest of the pyml_bindgen code, so they are guaranteed to be up-to-date and working.","title":"Lots of examples"},{"location":"examples/#lots-of-examples","text":"You can find a lot of examples on GitHub . These examples are particularly cool because they show you how to use Dune rules to generate bindings automatically. Also, they are tested along with the rest of the pyml_bindgen code, so they are guaranteed to be up-to-date and working.","title":"Lots of Examples"},{"location":"getting-started/","text":"Getting Started To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do things in a particular way, i.e., using named arguments. Binding constructors __init__ in Python constructs an instance of the class. While in Python you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit . Using a different name for functions Sometimes you may want to use a different name for a function or an argument on the OCaml side than is used on the Python side. This will often be the case for binding constructors. To do so you can use the py_fun_name attribute. Check it out. val create : x:int -> unit -> t [@@py_fun_name __init__] This tells pyml_bindgen that we want to use create on the OCaml side, and bind it to the Python __init__ function for the class we're currently working on. For more on this, check out the attributes example on GitHub. Binding instance methods Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods. Binding static methods Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that they don't start with a t argument, and each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods. Binding instance attributes Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int You can find more info on binding attributes in the attributes & properties section of the manual. Running pyml_bindgen Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly. Using the generated module While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1 Next steps These are just a few of the ways you can use pyml_bindgen . I suggest you take a look at the examples on GitHub for more information.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do things in a particular way, i.e., using named arguments.","title":"Getting Started"},{"location":"getting-started/#binding-constructors","text":"__init__ in Python constructs an instance of the class. While in Python you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit .","title":"Binding constructors"},{"location":"getting-started/#using-a-different-name-for-functions","text":"Sometimes you may want to use a different name for a function or an argument on the OCaml side than is used on the Python side. This will often be the case for binding constructors. To do so you can use the py_fun_name attribute. Check it out. val create : x:int -> unit -> t [@@py_fun_name __init__] This tells pyml_bindgen that we want to use create on the OCaml side, and bind it to the Python __init__ function for the class we're currently working on. For more on this, check out the attributes example on GitHub.","title":"Using a different name for functions"},{"location":"getting-started/#binding-instance-methods","text":"Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods.","title":"Binding instance methods"},{"location":"getting-started/#binding-static-methods","text":"Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that they don't start with a t argument, and each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods.","title":"Binding static methods"},{"location":"getting-started/#binding-instance-attributes","text":"Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int You can find more info on binding attributes in the attributes & properties section of the manual.","title":"Binding instance attributes"},{"location":"getting-started/#running-pyml_bindgen","text":"Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly.","title":"Running pyml_bindgen"},{"location":"getting-started/#using-the-generated-module","text":"While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1","title":"Using the generated module"},{"location":"getting-started/#next-steps","text":"These are just a few of the ways you can use pyml_bindgen . I suggest you take a look at the examples on GitHub for more information.","title":"Next steps"},{"location":"gotchas-bugs/","text":"Gotchas & Known Bugs You cannot bind Python properties or attributes that return None . So, val f : t -> unit will currently fail.","title":"Gotchas & Known Bugs"},{"location":"gotchas-bugs/#gotchas-known-bugs","text":"You cannot bind Python properties or attributes that return None . So, val f : t -> unit will currently fail.","title":"Gotchas &amp; Known Bugs"},{"location":"instance-methods/","text":"Instance Methods Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c Rules The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned earlier. The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned earlier. Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future.","title":"Instance Methods"},{"location":"instance-methods/#instance-methods","text":"Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Instance Methods"},{"location":"instance-methods/#rules","text":"The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned earlier. The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned earlier. Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future.","title":"Rules"},{"location":"matplotlib-2/","text":"Another matplotlib example Let's take another look at matplotlib . This one will be a little different in that we will generate direct bindings for a couple of matplotlib classes and module functions. Axes Figure matplotlib.pyplot.subplots This example will also show you some of the current limitations of pyml_bindgen :) Value specs For this example, we won't bother binding all the arguments that these methods take since we won't be using them. For each of these, I will put down the arguments as shown in the matplotlib docs, the follow it with the OCaml value spec we will use. Axes.set_title ( docs ) Python: Axes.set_title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs) OCaml: val set_title : t -> label:string -> unit -> unit Axes.plot ( docs ) Python: Axes.plot(*args, scalex=True, scaley=True, data=None, **kwargs) OCaml: val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit This value spec will generate an Axes.plot function actually has a bug. If you check the docs, you can't actually pass x and y as keyword arguments. Oops! You have to go in and edit the binding by hand. Below, I will show a patch file with the changes you need to make. You may be thinking, well, that's pretty annoying...I agree! For this function, I would probably just write it by hand from the start. I'm showing it here partly as a reminder that I want to change the behaviour of pyml_bindgen in a future release to handle methods like this one. But for now, you have to deal with it yourself :) Note that while we used float list for x and y here, you may want to use float array instead. Figure.savefig ( docs ) savefig(fname, *, transparent=None, **kwargs) val savefig : t -> fname:string -> unit -> unit Generating Axes & Figure modules Let's go over the arguments and options for pyml_bindgen that we will need. Note that we need to specify the correct Python module from which the Axes and Figure classes come. For Axes , that's matplotlib.axes . For Figure , that's matplotlib.figure . We use --caml-module option again to tell pyml_bindgen to generate the module signature as well as the implementation. We use -a class to specify that we want to generate class-associated methods. Note that this is the default option. For both invocations, we pipe the output directly to ocamlformat . Run pyml_bindgen Here are the commands. pyml_bindgen axes_specs.txt matplotlib.axes Axes --caml-module Axes -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ > py_class.ml printf \"\\n\" >> py_class.ml pyml_bindgen figure_specs.txt matplotlib.figure Figure --caml-module Figure -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ >> py_class.ml Patch the file Above, I mentioned that you would need to change the implementation for the Axes module a bit. Here is the patch for the lines you need to change. Here is a patch showing the change I mean --- py_class_bug.ml 2021-10-20 20:21:00.000000000 -0400 +++ py_class.ml 2021-10-20 20:21:00.000000000 -0400 @@ -30,17 +30,21 @@ let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in + let args = + [| + Py.List.of_list_map Py.Float.of_float x; + Py.List.of_list_map Py.Float.of_float y; + |] + in let kwargs = filter_opt [ - Some (\"x\", Py.List.of_list_map Py.Float.of_float x); - Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in - ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs + ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig Generated output Here's the whole of the generated output including the patch. module Axes : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val set_title : t -> label:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.axes\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Axes\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let set_title t ~label () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"label\", Py.String.of_string label) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let args = [| Py.List.of_list_map Py.Float.of_float x; Py.List.of_list_map Py.Float.of_float y; |] in let kwargs = filter_opt [ (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val savefig : t -> fname:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.figure\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Figure\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let savefig t ~fname () = let callable = Py.Object.find_attr_string t \"savefig\" in let kwargs = filter_opt [ Some (\"fname\", Py.String.of_string fname) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Write the Pyplot module For a little variety, and because we don't need any of the extra stuff that pyml_bindgen generates (again, you will be able to control this eventually), let's write this one by hand. Then you can make a pyplot.ml file open Py_class let import_module () = Py.Import.import_module \"matplotlib.pyplot\" let subplots () = let callable = Py.Module.get (import_module ()) \"subplots\" in let args = [||] in let kwargs = [] in let tup = Py.Callable.to_function_with_keywords callable args kwargs in let fig, ax = Py.Tuple.to_tuple2 tup in match (Figure.of_pyobject fig, Axes.of_pyobject ax) with | Some f, Some a -> Some (f, a) | Some _, None | None, Some _ | None, None -> None Note that there are more compact ways to write this with pyml , but we will leave it like this to keep it similar to the rest of the generated functions. Set up the Dune project and run it Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries pyml)) run.ml open Py_class let () = Py.initialize () let figure, axes = match Pyplot.subplots () with | Some (fig, ax) -> (fig, ax) | None -> failwith \"Failed to make figure and axes!\" let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let () = Axes.set_title axes ~label:\"Brown Plot\" () let () = Axes.plot axes ~x ~y ~color:\"tab:brown\" () let () = Figure.savefig figure ~fname:\"brown_plot.png\" () Run it like so: $ dune exec ./run.exe If all goes well, you should see a nice, brown line plot: Wrap up In this tutorial, we generating bindings for a couple of matplotlib classes and functions. You saw how to combine multiple generated modules as well as some of the little workarounds you still have to do. Like all the examples so far, we're only binding a couple of classes & functions. For such a small thing, feel free to write your bindings by hand. These two classes alone have tons of functions though, so if you were binding them all, that would be a pain to write by hand!","title":"Matplotlib Example 2"},{"location":"matplotlib-2/#another-matplotlib-example","text":"Let's take another look at matplotlib . This one will be a little different in that we will generate direct bindings for a couple of matplotlib classes and module functions. Axes Figure matplotlib.pyplot.subplots This example will also show you some of the current limitations of pyml_bindgen :)","title":"Another matplotlib example"},{"location":"matplotlib-2/#value-specs","text":"For this example, we won't bother binding all the arguments that these methods take since we won't be using them. For each of these, I will put down the arguments as shown in the matplotlib docs, the follow it with the OCaml value spec we will use.","title":"Value specs"},{"location":"matplotlib-2/#axesset_title","text":"( docs ) Python: Axes.set_title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs) OCaml: val set_title : t -> label:string -> unit -> unit","title":"Axes.set_title"},{"location":"matplotlib-2/#axesplot","text":"( docs ) Python: Axes.plot(*args, scalex=True, scaley=True, data=None, **kwargs) OCaml: val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit This value spec will generate an Axes.plot function actually has a bug. If you check the docs, you can't actually pass x and y as keyword arguments. Oops! You have to go in and edit the binding by hand. Below, I will show a patch file with the changes you need to make. You may be thinking, well, that's pretty annoying...I agree! For this function, I would probably just write it by hand from the start. I'm showing it here partly as a reminder that I want to change the behaviour of pyml_bindgen in a future release to handle methods like this one. But for now, you have to deal with it yourself :) Note that while we used float list for x and y here, you may want to use float array instead.","title":"Axes.plot"},{"location":"matplotlib-2/#figuresavefig","text":"( docs ) savefig(fname, *, transparent=None, **kwargs) val savefig : t -> fname:string -> unit -> unit","title":"Figure.savefig"},{"location":"matplotlib-2/#generating-axes-figure-modules","text":"Let's go over the arguments and options for pyml_bindgen that we will need. Note that we need to specify the correct Python module from which the Axes and Figure classes come. For Axes , that's matplotlib.axes . For Figure , that's matplotlib.figure . We use --caml-module option again to tell pyml_bindgen to generate the module signature as well as the implementation. We use -a class to specify that we want to generate class-associated methods. Note that this is the default option. For both invocations, we pipe the output directly to ocamlformat .","title":"Generating Axes &amp; Figure modules"},{"location":"matplotlib-2/#run-pyml_bindgen","text":"Here are the commands. pyml_bindgen axes_specs.txt matplotlib.axes Axes --caml-module Axes -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ > py_class.ml printf \"\\n\" >> py_class.ml pyml_bindgen figure_specs.txt matplotlib.figure Figure --caml-module Figure -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ >> py_class.ml","title":"Run pyml_bindgen"},{"location":"matplotlib-2/#patch-the-file","text":"Above, I mentioned that you would need to change the implementation for the Axes module a bit. Here is the patch for the lines you need to change. Here is a patch showing the change I mean --- py_class_bug.ml 2021-10-20 20:21:00.000000000 -0400 +++ py_class.ml 2021-10-20 20:21:00.000000000 -0400 @@ -30,17 +30,21 @@ let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in + let args = + [| + Py.List.of_list_map Py.Float.of_float x; + Py.List.of_list_map Py.Float.of_float y; + |] + in let kwargs = filter_opt [ - Some (\"x\", Py.List.of_list_map Py.Float.of_float x); - Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in - ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs + ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig","title":"Patch the file"},{"location":"matplotlib-2/#generated-output","text":"Here's the whole of the generated output including the patch. module Axes : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val set_title : t -> label:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.axes\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Axes\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let set_title t ~label () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"label\", Py.String.of_string label) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let args = [| Py.List.of_list_map Py.Float.of_float x; Py.List.of_list_map Py.Float.of_float y; |] in let kwargs = filter_opt [ (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val savefig : t -> fname:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.figure\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Figure\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let savefig t ~fname () = let callable = Py.Object.find_attr_string t \"savefig\" in let kwargs = filter_opt [ Some (\"fname\", Py.String.of_string fname) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Generated output"},{"location":"matplotlib-2/#write-the-pyplot-module","text":"For a little variety, and because we don't need any of the extra stuff that pyml_bindgen generates (again, you will be able to control this eventually), let's write this one by hand. Then you can make a pyplot.ml file open Py_class let import_module () = Py.Import.import_module \"matplotlib.pyplot\" let subplots () = let callable = Py.Module.get (import_module ()) \"subplots\" in let args = [||] in let kwargs = [] in let tup = Py.Callable.to_function_with_keywords callable args kwargs in let fig, ax = Py.Tuple.to_tuple2 tup in match (Figure.of_pyobject fig, Axes.of_pyobject ax) with | Some f, Some a -> Some (f, a) | Some _, None | None, Some _ | None, None -> None Note that there are more compact ways to write this with pyml , but we will leave it like this to keep it similar to the rest of the generated functions.","title":"Write the Pyplot module"},{"location":"matplotlib-2/#set-up-the-dune-project-and-run-it","text":"Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries pyml)) run.ml open Py_class let () = Py.initialize () let figure, axes = match Pyplot.subplots () with | Some (fig, ax) -> (fig, ax) | None -> failwith \"Failed to make figure and axes!\" let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let () = Axes.set_title axes ~label:\"Brown Plot\" () let () = Axes.plot axes ~x ~y ~color:\"tab:brown\" () let () = Figure.savefig figure ~fname:\"brown_plot.png\" () Run it like so: $ dune exec ./run.exe If all goes well, you should see a nice, brown line plot:","title":"Set up the Dune project and run it"},{"location":"matplotlib-2/#wrap-up","text":"In this tutorial, we generating bindings for a couple of matplotlib classes and functions. You saw how to combine multiple generated modules as well as some of the little workarounds you still have to do. Like all the examples so far, we're only binding a couple of classes & functions. For such a small thing, feel free to write your bindings by hand. These two classes alone have tons of functions though, so if you were binding them all, that would be a pain to write by hand!","title":"Wrap up"},{"location":"matplotlib/","text":"Matplotlib Example Okay, okay...this is a sort of fake example. Instead of wrapping a whole bunch of matplotlib code, we're just going to bind a little class that wraps some basic plotting functionality. Just pretend it's some cool coworker's code that you want to access from OCaml :) import matplotlib.pyplot as plt class Plotter: def __init__(self): self.fig, self.ax = plt.subplots() def set_title(self, title): self.ax.set_title(title) def plot(self, x, y, color='tab:blue'): self.ax.plot(x, y, color=color) def save(self, filename): self.fig.savefig(filename) As you can see, it's a simple class that wraps some matplotlib functionality. This example is a bit different than the first one in that no meaningful values are ever returned from the Python methods. It's all just state internal to the Python objects. While you could probably imagine a nicer interface to this class that hides away all the yuck, we are just going to do a straight binding of the methods as they are. Unlike the last example, we are not going to bother with exposing the attributes, since the caller won't need them. We will do all the methods though. Recall that when binding instance methods, the first argument must be t , the last argument must be unit , and the remaining arguments must be named or optional. Value specs __init__ This __init__ function takes no arguments, and returns an instance of Plotter . val __init__ : unit -> t set_title set_title takes a single string argument title , (and self of course, but we don't worry about that from the OCaml side). In Python-land, set_title returns None . In cases like this, we want an OCaml function that returns unit . val set_title : t -> title:string -> unit -> unit We have unit -> unit because the return type is unit , and the final argument of the function needs to be unit . plot The plot function is kind of interesting since it takes an optional argument color . Just because the argument is optional on the Python side doesn't mean that we have to make it optional on the OCaml side, but let's go ahead and make it optional to match the Python API to show you how it's done. (While you could definitely imagine using some sort of variant for a color argument, we will just match the Python and use a string.) val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit Not bad! You just make it like any old OCaml optional argument. Note that while we used float list for x and y here, you may want to use float array instead. save Finally, the save function. Nothing new to talk about so I'll just put down the spec. val save : t -> filename:string -> unit -> unit Put those all in a file called val_specs.txt . Here it is for easy copy-pasting. val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit Run pyml_bindgen Run the following command to generate the OCaml module. $ pyml_bindgen val_specs.txt plotter Plotter --caml-module=Plotter --of-pyo-ret-type=no_check > lib.ml For more info about the options, see the getting started example. For reference, here is the generated source code after running ocamlformat . module Plotter : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"plotter\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let __init__ () = let callable = Py.Module.get (import_module ()) \"Plotter\" in let kwargs = filter_opt [] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let set_title t ~title () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"title\", Py.String.of_string title) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let kwargs = filter_opt [ Some (\"x\", Py.List.of_list_map Py.Float.of_float x); Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let save t ~filename () = let callable = Py.Object.find_attr_string t \"save\" in let kwargs = filter_opt [ Some (\"filename\", Py.String.of_string filename) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Set up the Dune project Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in which you generated the lib.ml file. dune (executable (name run) (libraries pyml)) run.ml open Lib let () = Py.initialize () let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Silly Plot\" () (* See how [color] is optional? *) let () = Plotter.plot plotter ~x ~y () let () = Plotter.save plotter ~filename:\"silly_plot.png\" () let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Orange Plot\" () (* Here, we pass the [color] argument. *) let () = Plotter.plot plotter ~x ~y ~color:\"tab:orange\" () let () = Plotter.save plotter ~filename:\"orange_plot.png\" () And now, go ahead and run that. $ dune exec ./run.exe If all goes well, you should see a couple of PNG files there. Here's what they should look like. The first plot, with default colors: And the orange plot: Pretty cool, right? Wrap up Okay, so this was kind of a goofy example. It's a little artificial, as you probably would want to just bind to matplotlib directly, but to keep things simple, we just used a simple class that binds some matplotlib functionality. It did show you some new stuff, though, and we got to make some cute plots! \ud83d\udcc8 \ud83d\udcca","title":"Matplotlib Example"},{"location":"matplotlib/#matplotlib-example","text":"Okay, okay...this is a sort of fake example. Instead of wrapping a whole bunch of matplotlib code, we're just going to bind a little class that wraps some basic plotting functionality. Just pretend it's some cool coworker's code that you want to access from OCaml :) import matplotlib.pyplot as plt class Plotter: def __init__(self): self.fig, self.ax = plt.subplots() def set_title(self, title): self.ax.set_title(title) def plot(self, x, y, color='tab:blue'): self.ax.plot(x, y, color=color) def save(self, filename): self.fig.savefig(filename) As you can see, it's a simple class that wraps some matplotlib functionality. This example is a bit different than the first one in that no meaningful values are ever returned from the Python methods. It's all just state internal to the Python objects. While you could probably imagine a nicer interface to this class that hides away all the yuck, we are just going to do a straight binding of the methods as they are. Unlike the last example, we are not going to bother with exposing the attributes, since the caller won't need them. We will do all the methods though. Recall that when binding instance methods, the first argument must be t , the last argument must be unit , and the remaining arguments must be named or optional.","title":"Matplotlib Example"},{"location":"matplotlib/#value-specs","text":"","title":"Value specs"},{"location":"matplotlib/#__init__","text":"This __init__ function takes no arguments, and returns an instance of Plotter . val __init__ : unit -> t","title":"__init__"},{"location":"matplotlib/#set_title","text":"set_title takes a single string argument title , (and self of course, but we don't worry about that from the OCaml side). In Python-land, set_title returns None . In cases like this, we want an OCaml function that returns unit . val set_title : t -> title:string -> unit -> unit We have unit -> unit because the return type is unit , and the final argument of the function needs to be unit .","title":"set_title"},{"location":"matplotlib/#plot","text":"The plot function is kind of interesting since it takes an optional argument color . Just because the argument is optional on the Python side doesn't mean that we have to make it optional on the OCaml side, but let's go ahead and make it optional to match the Python API to show you how it's done. (While you could definitely imagine using some sort of variant for a color argument, we will just match the Python and use a string.) val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit Not bad! You just make it like any old OCaml optional argument. Note that while we used float list for x and y here, you may want to use float array instead.","title":"plot"},{"location":"matplotlib/#save","text":"Finally, the save function. Nothing new to talk about so I'll just put down the spec. val save : t -> filename:string -> unit -> unit Put those all in a file called val_specs.txt . Here it is for easy copy-pasting. val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit","title":"save"},{"location":"matplotlib/#run-pyml_bindgen","text":"Run the following command to generate the OCaml module. $ pyml_bindgen val_specs.txt plotter Plotter --caml-module=Plotter --of-pyo-ret-type=no_check > lib.ml For more info about the options, see the getting started example. For reference, here is the generated source code after running ocamlformat . module Plotter : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"plotter\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let __init__ () = let callable = Py.Module.get (import_module ()) \"Plotter\" in let kwargs = filter_opt [] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let set_title t ~title () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"title\", Py.String.of_string title) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let kwargs = filter_opt [ Some (\"x\", Py.List.of_list_map Py.Float.of_float x); Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let save t ~filename () = let callable = Py.Object.find_attr_string t \"save\" in let kwargs = filter_opt [ Some (\"filename\", Py.String.of_string filename) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Run pyml_bindgen"},{"location":"matplotlib/#set-up-the-dune-project","text":"Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in which you generated the lib.ml file. dune (executable (name run) (libraries pyml)) run.ml open Lib let () = Py.initialize () let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Silly Plot\" () (* See how [color] is optional? *) let () = Plotter.plot plotter ~x ~y () let () = Plotter.save plotter ~filename:\"silly_plot.png\" () let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Orange Plot\" () (* Here, we pass the [color] argument. *) let () = Plotter.plot plotter ~x ~y ~color:\"tab:orange\" () let () = Plotter.save plotter ~filename:\"orange_plot.png\" () And now, go ahead and run that. $ dune exec ./run.exe If all goes well, you should see a couple of PNG files there. Here's what they should look like. The first plot, with default colors: And the orange plot: Pretty cool, right?","title":"Set up the Dune project"},{"location":"matplotlib/#wrap-up","text":"Okay, so this was kind of a goofy example. It's a little artificial, as you probably would want to just bind to matplotlib directly, but to keep things simple, we just used a simple class that binds some matplotlib functionality. It did show you some new stuff, though, and we got to make some cute plots! \ud83d\udcc8 \ud83d\udcca","title":"Wrap up"},{"location":"names/","text":"Function & Argument Names You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned previously are not allowed. Argument names that start with any of the types mentioned are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse. Reserved keywords Sometimes, you are binding a Python method that uses reserved OCaml identifiers either in the name of the method names of the arguments. You can get around this using attributes in your value specifications. val downto_ : from:int -> to_:int -> unit -> int array [@@py_fun_name downto] [@@py_arg_name to_ to] [@@py_arg_name from from_] (Here is the Python you're binding in this case.) def downto(from_, to): ...","title":"Function & Argument Names"},{"location":"names/#function-argument-names","text":"You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned previously are not allowed. Argument names that start with any of the types mentioned are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse.","title":"Function &amp; Argument Names"},{"location":"names/#reserved-keywords","text":"Sometimes, you are binding a Python method that uses reserved OCaml identifiers either in the name of the method names of the arguments. You can get around this using attributes in your value specifications. val downto_ : from:int -> to_:int -> unit -> int array [@@py_fun_name downto] [@@py_arg_name to_ to] [@@py_arg_name from from_] (Here is the Python you're binding in this case.) def downto(from_, to): ...","title":"Reserved keywords"},{"location":"ocaml-attributes/","text":"Attributes You can attach certain attributes to your value specifications to change their behavior. Currently, the only recognized attributes are py_fun_name and py_arg_name . You can use them to bind a Python method names and argument names to something else on the OCaml side. Example For example, rather than having a Cat.__init__ method to call from the OCaml side (i.e., to make a new Python Cat object), you can bind the Python __init__ function to something more idiomatic like create or whatever you want. val create : t -> ... [@@py_fun_name __init__] Another common use for this is to bind the Python __str__ method for a class to to_string on the OCaml side. You can do this with any function. One reason is that you may want to have some type safety with a polymorphic Python function. While you could pass in Py.Object.t directly, you could also use attributes to bind multiple OCaml functions to the same Python method. E.g., val eat : t -> num_mice:int -> unit -> unit val eat_part : t -> num_mice:float -> unit -> unit [@@py_fun_name eat] In this case, we have one eat function for int and one for float . Full example For a full working example see the attributes example on GitHub. The linked example also shows how to use py_arg_name . Warning If you specify the py_fun_name more than once, it will do something wonky. Eventually, the program will treat this as an error, but for now, it is on you to avoid doing it. Attributes have to start a line. I.e., if you have more than one attribute, you can't put them on the same line. They must go on separate lines.","title":"Attributes -- py_fun_name"},{"location":"ocaml-attributes/#attributes","text":"You can attach certain attributes to your value specifications to change their behavior. Currently, the only recognized attributes are py_fun_name and py_arg_name . You can use them to bind a Python method names and argument names to something else on the OCaml side.","title":"Attributes"},{"location":"ocaml-attributes/#example","text":"For example, rather than having a Cat.__init__ method to call from the OCaml side (i.e., to make a new Python Cat object), you can bind the Python __init__ function to something more idiomatic like create or whatever you want. val create : t -> ... [@@py_fun_name __init__] Another common use for this is to bind the Python __str__ method for a class to to_string on the OCaml side. You can do this with any function. One reason is that you may want to have some type safety with a polymorphic Python function. While you could pass in Py.Object.t directly, you could also use attributes to bind multiple OCaml functions to the same Python method. E.g., val eat : t -> num_mice:int -> unit -> unit val eat_part : t -> num_mice:float -> unit -> unit [@@py_fun_name eat] In this case, we have one eat function for int and one for float .","title":"Example"},{"location":"ocaml-attributes/#full-example","text":"For a full working example see the attributes example on GitHub. The linked example also shows how to use py_arg_name .","title":"Full example"},{"location":"ocaml-attributes/#warning","text":"If you specify the py_fun_name more than once, it will do something wonky. Eventually, the program will treat this as an error, but for now, it is on you to avoid doing it. Attributes have to start a line. I.e., if you have more than one attribute, you can't put them on the same line. They must go on separate lines.","title":"Warning"},{"location":"of-pyobject/","text":"Converting pyobjects to OCaml Types With pyml_bindgen , you are generally want to set up a binding from a single Python class to a single OCaml module. E.g., class Foo: def __init__(self, x) self.x = x def add1(self): self.x += 1 would have a corresponding module something like this module Foo : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val x : t -> int val add1 : t -> unit -> unit end = struct type t = Pytypes.pyobject let of_pyobject x = x let to_pyobject x = x let add1 t () = end In the above example, we don't bother checking the Python-land type of the pyobject . All OCaml compiler knows at compile time is that we are taking a Pytypes.pyobject type and getting back a Foo.t . Depending on how that pyobject was actually created elsewhere in the code, it might not actually be an instance of the Foo class. In this case, when you go to call the Foo.say_hi function in your OCaml code, you will get a runtime error. Let me give you an example. let i = Py.Int.of_int 1 assert let foo = Foo.of_pyobject i let _ = Foo.say_hi foo () (* ERROR! *) You'll get an exception: Exception: E (<class 'AttributeError'>, 'int' object has no attribute 'add1') . Checking pyobjects at module boundaries While you could remove the of_pyobject function from the interface, you are often going to need it outside the module. For example, you may have a Python class Foo that has a method which returns an object of class Bar . In your OCaml code you'd need to call the Bar.of_pyobject method from inside the Foo module. Basically, you would like to have an of_pyobject that actually checks that the underlying Python type is what the module expects. I.e., you only want to create a Foo.t if the pyobject is a Foo object in Python-land. You can address this problem in the typical OCaml way (e.g., by returning t option or t Or_error.t instead of t ) in pyml_bindgen as well. Let's see what I mean. pyml_bindgen automatically generates of_pyobject and to_pyobject functions for you (in fact, you shouldn't provide those yourself). You can generate three kinds of_pyobject function with pyml_bindgen : No checking: val of_pyobject : Pytypes.pyobject -> t option returning: val of_pyobject : Pytypes.pyobject -> t option Base Or_error.t returning: val of_pyobject : Pytypes.pyobject -> t Or_error.t You can choose between the three with the --of-pyo-ret-type option. Here is the section from the man page: -r OF_PYO_RET_TYPE, --of-pyo-ret-type=OF_PYO_RET_TYPE (absent=option) Return type of the of_pyobject function. OF_PYO_RET_TYPE must be one of `no_check', `option' or `or_error'. While the option and Or_error.t let you avoid a lot of potential runtime problems, they will force you to deal with potential errors each time of_pyobject is called, and in code generated by pyml_bindgen you may not realize that it is being called! Say that you generated both Person and Job modules with the --of-pyo-ret-type=option command line option. Then both of these modules will have of_pyobject functions that return t option rather than just t . Note: For now, you can only generate one of these module signatures at a time with pyml_bindgen . To combine them, you'll have to run it multiple times and then combine manually. Here is an example of code that won't work. module rec Person : sig type t val of_pyobject : Pytypes.pyobject -> t option (* Oops! *) val get_job : t -> unit -> Job.t ... end = struct ... end and Job : sig type t val of_pyobject : Pytypes.pyobject -> t option ... end = struct ... end When pyml_bindgen sees a function that ends in a custom type (a module type like Job.t , Person.t , or whatever), the generated code will call that type's of_pyobject function to convert it to the correct OCaml type. So, for Person.get_job it will generate a function that calls Job.of_pyobject somewhere in the get_job implementation. Of course, Job.of_pyobject returns Job.t option and not Job.t . But in the Person.get_job signature, we've specified that get_job returns Job.t and NOT Job.t option . Now, pyml_bindgen will happily generate this implementation for you, but when you try to actually compile it, you will get an error about the return type of get_job implementation not matching the expected signature. So what do you do? Well, you have to remember that the --of-pyo-ret-type=option and --of-pyo-ret-type=or_error flags will essentially poison all generated functions that manipulate other auto-generated modules. Specifically, for this example, you can't write val get_job : t -> unit -> Job.t . Instead, you have to write val get_job : t -> unit -> Job.t option . Just so that it's clear, the reason is because Job.of_pyobject returns Job.t option , and the generated implementation of Person.get_job will call Job.of_pyobject somewhere in its body.) Wrap-up You have to be aware of the return types of the of_pyobject functions you're generating with pyml_bindgen . If you use option or Or_error.t , you have to remember to adjust your value specifications accordingly!","title":"Converting `pyobjects` to OCaml types"},{"location":"of-pyobject/#converting-pyobjects-to-ocaml-types","text":"With pyml_bindgen , you are generally want to set up a binding from a single Python class to a single OCaml module. E.g., class Foo: def __init__(self, x) self.x = x def add1(self): self.x += 1 would have a corresponding module something like this module Foo : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val x : t -> int val add1 : t -> unit -> unit end = struct type t = Pytypes.pyobject let of_pyobject x = x let to_pyobject x = x let add1 t () = end In the above example, we don't bother checking the Python-land type of the pyobject . All OCaml compiler knows at compile time is that we are taking a Pytypes.pyobject type and getting back a Foo.t . Depending on how that pyobject was actually created elsewhere in the code, it might not actually be an instance of the Foo class. In this case, when you go to call the Foo.say_hi function in your OCaml code, you will get a runtime error. Let me give you an example. let i = Py.Int.of_int 1 assert let foo = Foo.of_pyobject i let _ = Foo.say_hi foo () (* ERROR! *) You'll get an exception: Exception: E (<class 'AttributeError'>, 'int' object has no attribute 'add1') .","title":"Converting pyobjects to OCaml Types"},{"location":"of-pyobject/#checking-pyobjects-at-module-boundaries","text":"While you could remove the of_pyobject function from the interface, you are often going to need it outside the module. For example, you may have a Python class Foo that has a method which returns an object of class Bar . In your OCaml code you'd need to call the Bar.of_pyobject method from inside the Foo module. Basically, you would like to have an of_pyobject that actually checks that the underlying Python type is what the module expects. I.e., you only want to create a Foo.t if the pyobject is a Foo object in Python-land. You can address this problem in the typical OCaml way (e.g., by returning t option or t Or_error.t instead of t ) in pyml_bindgen as well. Let's see what I mean. pyml_bindgen automatically generates of_pyobject and to_pyobject functions for you (in fact, you shouldn't provide those yourself). You can generate three kinds of_pyobject function with pyml_bindgen : No checking: val of_pyobject : Pytypes.pyobject -> t option returning: val of_pyobject : Pytypes.pyobject -> t option Base Or_error.t returning: val of_pyobject : Pytypes.pyobject -> t Or_error.t You can choose between the three with the --of-pyo-ret-type option. Here is the section from the man page: -r OF_PYO_RET_TYPE, --of-pyo-ret-type=OF_PYO_RET_TYPE (absent=option) Return type of the of_pyobject function. OF_PYO_RET_TYPE must be one of `no_check', `option' or `or_error'. While the option and Or_error.t let you avoid a lot of potential runtime problems, they will force you to deal with potential errors each time of_pyobject is called, and in code generated by pyml_bindgen you may not realize that it is being called! Say that you generated both Person and Job modules with the --of-pyo-ret-type=option command line option. Then both of these modules will have of_pyobject functions that return t option rather than just t . Note: For now, you can only generate one of these module signatures at a time with pyml_bindgen . To combine them, you'll have to run it multiple times and then combine manually. Here is an example of code that won't work. module rec Person : sig type t val of_pyobject : Pytypes.pyobject -> t option (* Oops! *) val get_job : t -> unit -> Job.t ... end = struct ... end and Job : sig type t val of_pyobject : Pytypes.pyobject -> t option ... end = struct ... end When pyml_bindgen sees a function that ends in a custom type (a module type like Job.t , Person.t , or whatever), the generated code will call that type's of_pyobject function to convert it to the correct OCaml type. So, for Person.get_job it will generate a function that calls Job.of_pyobject somewhere in the get_job implementation. Of course, Job.of_pyobject returns Job.t option and not Job.t . But in the Person.get_job signature, we've specified that get_job returns Job.t and NOT Job.t option . Now, pyml_bindgen will happily generate this implementation for you, but when you try to actually compile it, you will get an error about the return type of get_job implementation not matching the expected signature. So what do you do? Well, you have to remember that the --of-pyo-ret-type=option and --of-pyo-ret-type=or_error flags will essentially poison all generated functions that manipulate other auto-generated modules. Specifically, for this example, you can't write val get_job : t -> unit -> Job.t . Instead, you have to write val get_job : t -> unit -> Job.t option . Just so that it's clear, the reason is because Job.of_pyobject returns Job.t option , and the generated implementation of Person.get_job will call Job.of_pyobject somewhere in its body.)","title":"Checking pyobjects at module boundaries"},{"location":"of-pyobject/#wrap-up","text":"You have to be aware of the return types of the of_pyobject functions you're generating with pyml_bindgen . If you use option or Or_error.t , you have to remember to adjust your value specifications accordingly!","title":"Wrap-up"},{"location":"recursive/","text":"Binding Recursive Classes You will often run into cases in which you need to bind classes that are cyclical. Here's an example: class Foo: @staticmethod def make_bar(): return Bar() class Bar: @staticmethod def make_foo(): return Foo() Foo has a method that returns a Bar object, and Bar has a method that returns a Foo object. While this works fine in Python, we have to be more explicit in OCaml in these kinds of situations. Auto-generate bindings As of version 0.4.0-SNAPSHOT , pyml_bindgen ships two helper scripts for dealing with this type of thing automatically: gen_multi and combine_rec_modules . Check out the Recursive Modules example on GitHub for how to use them. Semi-manually generate bindings The pyml_bindgen itself doesn't handle recursive modules. But it is simple enough to edit the output by hand. Let's see how. Value specs Since there are two classes to bind, we will make two val spec files. foo_val_specs.txt val make_bar : unit -> Bar.t bar_val_specs.txt val make_foo : unit -> Foo.t Run pyml_bindgen Now, run pyml_bindgen with some extra shell commands to make the output look nicer. pyml_bindgen foo_val_specs.txt silly Foo --caml-module Foo -r no_check \\ | ocamlformat --enable --name=a.ml - > lib.ml printf \"\\n\" >> lib.ml pyml_bindgen bar_val_specs.txt silly Bar --caml-module Bar -r no_check \\ | ocamlformat --enable --name=a.ml - >> lib.ml Fix the output If you were to try and compile that code, you'd get a lot of errors including about unknown Bar module. To fix it, change module Foo : sig to module rec Foo : sig and module Bar : sig to and Bar : sig . Once you do that, everything will compile fine :) Here is what the output should look like: module rec Foo : sig ... sig ... end = struct ... impl ... end and Bar : sig ... sig ... end = struct ... impl ... end Using the generated modules You can use the generated modules as you would any others. open Lib let () = Py.initialize () let (_bar : Bar.t) = Foo.make_bar () let (_foo : Foo.t) = Bar.make_foo () Wrap-up You may come across cyclic classes when binding Python code. If you want to bind them in OCaml as it, you will need to use recursive module. This page shows you how to do it semi-manually using pyml_bindgen . If you would like a more automatic way to do this, see the Recursive Modules example on GitHub.","title":"Recursive Classes"},{"location":"recursive/#binding-recursive-classes","text":"You will often run into cases in which you need to bind classes that are cyclical. Here's an example: class Foo: @staticmethod def make_bar(): return Bar() class Bar: @staticmethod def make_foo(): return Foo() Foo has a method that returns a Bar object, and Bar has a method that returns a Foo object. While this works fine in Python, we have to be more explicit in OCaml in these kinds of situations.","title":"Binding Recursive Classes"},{"location":"recursive/#auto-generate-bindings","text":"As of version 0.4.0-SNAPSHOT , pyml_bindgen ships two helper scripts for dealing with this type of thing automatically: gen_multi and combine_rec_modules . Check out the Recursive Modules example on GitHub for how to use them.","title":"Auto-generate bindings"},{"location":"recursive/#semi-manually-generate-bindings","text":"The pyml_bindgen itself doesn't handle recursive modules. But it is simple enough to edit the output by hand. Let's see how.","title":"Semi-manually generate bindings"},{"location":"recursive/#value-specs","text":"Since there are two classes to bind, we will make two val spec files. foo_val_specs.txt val make_bar : unit -> Bar.t bar_val_specs.txt val make_foo : unit -> Foo.t","title":"Value specs"},{"location":"recursive/#run-pyml_bindgen","text":"Now, run pyml_bindgen with some extra shell commands to make the output look nicer. pyml_bindgen foo_val_specs.txt silly Foo --caml-module Foo -r no_check \\ | ocamlformat --enable --name=a.ml - > lib.ml printf \"\\n\" >> lib.ml pyml_bindgen bar_val_specs.txt silly Bar --caml-module Bar -r no_check \\ | ocamlformat --enable --name=a.ml - >> lib.ml","title":"Run pyml_bindgen"},{"location":"recursive/#fix-the-output","text":"If you were to try and compile that code, you'd get a lot of errors including about unknown Bar module. To fix it, change module Foo : sig to module rec Foo : sig and module Bar : sig to and Bar : sig . Once you do that, everything will compile fine :) Here is what the output should look like: module rec Foo : sig ... sig ... end = struct ... impl ... end and Bar : sig ... sig ... end = struct ... impl ... end","title":"Fix the output"},{"location":"recursive/#using-the-generated-modules","text":"You can use the generated modules as you would any others. open Lib let () = Py.initialize () let (_bar : Bar.t) = Foo.make_bar () let (_foo : Foo.t) = Bar.make_foo ()","title":"Using the generated modules"},{"location":"recursive/#wrap-up","text":"You may come across cyclic classes when binding Python code. If you want to bind them in OCaml as it, you will need to use recursive module. This page shows you how to do it semi-manually using pyml_bindgen . If you would like a more automatic way to do this, see the Recursive Modules example on GitHub.","title":"Wrap-up"},{"location":"rules-overview/","text":"Rules Overview The following pages are an informal description of some of the rules you have to follow when using pyml_bindgen . I will try and keep them updated and (reasonably) complete. However, if you really want to know how something is working, you may want to have a look at the tests or the examples .","title":"Overview"},{"location":"rules-overview/#rules-overview","text":"The following pages are an informal description of some of the rules you have to follow when using pyml_bindgen . I will try and keep them updated and (reasonably) complete. However, if you really want to know how something is working, you may want to have a look at the tests or the examples .","title":"Rules Overview"},{"location":"split-ml-mli/","text":"Splitting generated modules You can split the generated module into separate ml and mli files using the --split-caml-module option. For a full example of this, see the example on GitHub.","title":"Splitting ml and mli files"},{"location":"split-ml-mli/#splitting-generated-modules","text":"You can split the generated module into separate ml and mli files using the --split-caml-module option. For a full example of this, see the example on GitHub.","title":"Splitting generated modules"},{"location":"static-methods/","text":"Class & Static Methods; Functions Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c Rules The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned earlier. The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned earlier. Examples val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int Binding __init__ __init__ methods are called when constructing new Python objects. Here is an example. Python: class Person: def __init__(self, name, age): self.name = name self.age = age And the OCaml binding.... val __init__ : name:string -> age:int -> unit -> t If you want to generate functions that ensure the class is correct, you can return t option or t Or_error.t instead. Using a different name You can use a more natural name for the __init__ function. E.g., something like create by using attributs . val create : name:string -> age:int -> unit -> t [@@py_fun_name __init__] Functions You can also bind functions that are not associated with a class. The rules are the same for the class and static methods. To tell pyml_bindgen that you are actually binding module functions rather than class methods, you have to pass in a command line option --associated-with module .","title":"Class & Static Methods; Functions"},{"location":"static-methods/#class-static-methods-functions","text":"Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Class &amp; Static Methods; Functions"},{"location":"static-methods/#rules","text":"The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned earlier. The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned earlier.","title":"Rules"},{"location":"static-methods/#examples","text":"val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int","title":"Examples"},{"location":"static-methods/#binding-__init__","text":"__init__ methods are called when constructing new Python objects. Here is an example. Python: class Person: def __init__(self, name, age): self.name = name self.age = age And the OCaml binding.... val __init__ : name:string -> age:int -> unit -> t If you want to generate functions that ensure the class is correct, you can return t option or t Or_error.t instead.","title":"Binding __init__"},{"location":"static-methods/#using-a-different-name","text":"You can use a more natural name for the __init__ function. E.g., something like create by using attributs . val create : name:string -> age:int -> unit -> t [@@py_fun_name __init__]","title":"Using a different name"},{"location":"static-methods/#functions","text":"You can also bind functions that are not associated with a class. The rules are the same for the class and static methods. To tell pyml_bindgen that you are actually binding module functions rather than class methods, you have to pass in a command line option --associated-with module .","title":"Functions"},{"location":"todo/","text":"To do Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"todo/#to-do","text":"Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"tuples/","text":"Handling Tuples As of version 0.3.0, you can handle certain types of tuples directly. You can now bind tuples with 2, 3, 4, or 5 elements. They can be passed in as arguments, or returned from functions. Only basic types and Python objects are allowed in tuples. You can also put tuples inside of collections, e.g., (int * string) list , but not Options or Or_errors. If you need something more complicated then that, you will have to use some of the same tricks I talk about in the dictionaries or dictionaries-2 help pages. Examples You can find examples of binding tuples here .","title":"Handling Tuples"},{"location":"tuples/#handling-tuples","text":"As of version 0.3.0, you can handle certain types of tuples directly. You can now bind tuples with 2, 3, 4, or 5 elements. They can be passed in as arguments, or returned from functions. Only basic types and Python objects are allowed in tuples. You can also put tuples inside of collections, e.g., (int * string) list , but not Options or Or_errors. If you need something more complicated then that, you will have to use some of the same tricks I talk about in the dictionaries or dictionaries-2 help pages.","title":"Handling Tuples"},{"location":"tuples/#examples","text":"You can find examples of binding tuples here .","title":"Examples"},{"location":"types/","text":"Types Not all OCaml types are allowed. There are a lot of tests that exercise the rules here. Function arguments For function arguments, you can use float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Yummy.Apple_pie.t ) Arrays of any of the above types Lists of any of the above types Seq.t of any of the above types 'a option , 'a option array , 'a option list , 'a option Seq.t Pytypes.pyobject or Py.Object.t if you need to deal with pytypes directly Certain kinds of tuples Note that your custom types must be newly minted modules. E.g., (* This is okay *) module Doc = struct type t let of_pyobject ... let to_pyobject ... ... end (* But this is not *) type doc let doc_of_pyobject ... let doc_to_pyobject ... Return types For return types, you can use all of the above types plus unit , and 'a Or_error.t for types 'a other than unit . However, you cannot use unit array , unit list , or unit Seq.t . You can also return many kinds of tuples directly. See here . Nesting Note: currently, you're not allowed to have nested array , list , Seq.t , or Or_error.t . If you need them, you will have to bind those functions by hand :) E.g., 'a array list will fail. You are allowed to nest 'a option in arrays, lists, and Seq.t s (e.g., 'a option list ); however, this will not work with Or_error.t . Pytypes Sometimes you may want to deal directly with Pytypes.pyobject (a.k.a. Py.Object.t ). Maybe you have a Python function that is truly polymorphic, or you just don't feel like giving a function a specific OCaml type for whatever reason. Regardless, you can use Pytypes.pyobject or Py.Object.t for this. Of course, you will be leaking a bit of the pyml implementation into your API, but sometimes that is unavoidable, or just more convenient than dealing with it in another way. Note that you currently are not allowed to nest pytypes in any of the containers or monads. Tuples You can handle many kinds of tuples directly. See here . Dictionaries See here and here for examples of binding dictionaries. Alternatively, you could mark them as Pytypes.pyobject or Py.Object.t and let the caller deal with them in some way. Placeholders There are two placeholders you can use: todo and not_implemented . If you're binding a large library and you aren't planning on implementing a function, but you want it in the signature for whatever reason, you can use not_implemented . If you are planning to come back and implement a function later, you can use todo . val f : 'a todo val g : 'a not_implemented These are special in that you can't just use them anywhere, it has to be exactly as above. The generated functions for the above signatures will be like this: let f () = failwith \"todo: f\" let g () = failwith \"not implemented: g\" So if a user actually calls these functions, the program will fail at runtime.","title":"Types"},{"location":"types/#types","text":"Not all OCaml types are allowed. There are a lot of tests that exercise the rules here.","title":"Types"},{"location":"types/#function-arguments","text":"For function arguments, you can use float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Yummy.Apple_pie.t ) Arrays of any of the above types Lists of any of the above types Seq.t of any of the above types 'a option , 'a option array , 'a option list , 'a option Seq.t Pytypes.pyobject or Py.Object.t if you need to deal with pytypes directly Certain kinds of tuples Note that your custom types must be newly minted modules. E.g., (* This is okay *) module Doc = struct type t let of_pyobject ... let to_pyobject ... ... end (* But this is not *) type doc let doc_of_pyobject ... let doc_to_pyobject ...","title":"Function arguments"},{"location":"types/#return-types","text":"For return types, you can use all of the above types plus unit , and 'a Or_error.t for types 'a other than unit . However, you cannot use unit array , unit list , or unit Seq.t . You can also return many kinds of tuples directly. See here .","title":"Return types"},{"location":"types/#nesting","text":"Note: currently, you're not allowed to have nested array , list , Seq.t , or Or_error.t . If you need them, you will have to bind those functions by hand :) E.g., 'a array list will fail. You are allowed to nest 'a option in arrays, lists, and Seq.t s (e.g., 'a option list ); however, this will not work with Or_error.t .","title":"Nesting"},{"location":"types/#pytypes","text":"Sometimes you may want to deal directly with Pytypes.pyobject (a.k.a. Py.Object.t ). Maybe you have a Python function that is truly polymorphic, or you just don't feel like giving a function a specific OCaml type for whatever reason. Regardless, you can use Pytypes.pyobject or Py.Object.t for this. Of course, you will be leaking a bit of the pyml implementation into your API, but sometimes that is unavoidable, or just more convenient than dealing with it in another way. Note that you currently are not allowed to nest pytypes in any of the containers or monads.","title":"Pytypes"},{"location":"types/#tuples","text":"You can handle many kinds of tuples directly. See here .","title":"Tuples"},{"location":"types/#dictionaries","text":"See here and here for examples of binding dictionaries. Alternatively, you could mark them as Pytypes.pyobject or Py.Object.t and let the caller deal with them in some way.","title":"Dictionaries"},{"location":"types/#placeholders","text":"There are two placeholders you can use: todo and not_implemented . If you're binding a large library and you aren't planning on implementing a function, but you want it in the signature for whatever reason, you can use not_implemented . If you are planning to come back and implement a function later, you can use todo . val f : 'a todo val g : 'a not_implemented These are special in that you can't just use them anywhere, it has to be exactly as above. The generated functions for the above signatures will be like this: let f () = failwith \"todo: f\" let g () = failwith \"not implemented: g\" So if a user actually calls these functions, the program will fail at runtime.","title":"Placeholders"}]}