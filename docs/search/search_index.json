{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OCaml-Python Bindings Generator Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96 How to get started Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, you can either peruse the rules for writing value specifications that pyml_bindgen can understand, or check out more examples . If you have any questions or issues, please let me know about it on GitHub! Installing pyml_bindgen is a Dune project, so you should be able to clone the repository and build it with dune as long as you have the proper dependencies installed \ud83e\udd1e $ git clone https://github.com/mooreryan/pyml_bindgen.git $ cd pyml_bindgen $ opam install . --deps-only --with-doc --with-test $ dune test && dune build --profile=release && dune install $ pyml_bindgen --help ... help screen should show up ... Quick start pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml $ ocamlformat --enable-outside-detected-project lib.ml And here's the output of the ocamlformat command. let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read. License Software Copyright (c) 2021 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms. Documentation Copyright (c) 2021 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"pyml_bindgen"},{"location":"#ocaml-python-bindings-generator","text":"Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96","title":"OCaml-Python Bindings Generator"},{"location":"#how-to-get-started","text":"Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, you can either peruse the rules for writing value specifications that pyml_bindgen can understand, or check out more examples . If you have any questions or issues, please let me know about it on GitHub!","title":"How to get started"},{"location":"#installing","text":"pyml_bindgen is a Dune project, so you should be able to clone the repository and build it with dune as long as you have the proper dependencies installed \ud83e\udd1e $ git clone https://github.com/mooreryan/pyml_bindgen.git $ cd pyml_bindgen $ opam install . --deps-only --with-doc --with-test $ dune test && dune build --profile=release && dune install $ pyml_bindgen --help ... help screen should show up ...","title":"Installing"},{"location":"#quick-start","text":"pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml $ ocamlformat --enable-outside-detected-project lib.ml And here's the output of the ocamlformat command. let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read.","title":"Quick start"},{"location":"#license","text":"","title":"License"},{"location":"#software","text":"Copyright (c) 2021 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms.","title":"Software"},{"location":"#documentation","text":"Copyright (c) 2021 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"Documentation"},{"location":"attributes/","text":"Attributes & Properties Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a Rules The first and only function argument must be t . The return type can be any of the types mentioned above . Examples val x : t -> int val name : t -> string val price : t -> float","title":"Attributes & Properties"},{"location":"attributes/#attributes-properties","text":"Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a","title":"Attributes &amp; Properties"},{"location":"attributes/#rules","text":"The first and only function argument must be t . The return type can be any of the types mentioned above .","title":"Rules"},{"location":"attributes/#examples","text":"val x : t -> int val name : t -> string val price : t -> float","title":"Examples"},{"location":"getting-started/","text":"Getting Started To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do the obvious thing write OCaml functions with the same names as the Python methods. You also need to use named (or optional) arguments. Binding constructors __init__ in Python constructs an instance of the class. While you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit . See here for more about why that is. Binding instance methods Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods. Binding static methods TODO: we only have tests for static methods, but class methods should be the same...check it! Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods. Binding instance attributes Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int One thing to keep in mind is that many Python function can take values of different types. We could bind x with an OCaml function that returns float . In cases where you're binding polymorphic python functions, let the rest of your API guide you on how you'd like to type everything. You can find more info on binding attributes in the attributes & properties section of the manual. Running pyml_bindgen Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly. For more info on pyml_bindgen options, see here . I ran lib.ml through ocamlformat so it's easier to read here, but of course, that's optional! $ ocamlformat lib.ml --enable-outside-detected-project And here's the output: let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int val sub : a:int -> b:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs let sub ~a ~b () = let class_ = Py.Module.get (import_module ()) \"Thing\" in let callable = Py.Object.find_attr_string class_ \"sub\" in let kwargs = filter_opt [ Some (\"a\", Py.Int.of_int a); Some (\"b\", Py.Int.of_int b) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Using the generated module While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do the obvious thing write OCaml functions with the same names as the Python methods. You also need to use named (or optional) arguments.","title":"Getting Started"},{"location":"getting-started/#binding-constructors","text":"__init__ in Python constructs an instance of the class. While you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit . See here for more about why that is.","title":"Binding constructors"},{"location":"getting-started/#binding-instance-methods","text":"Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods.","title":"Binding instance methods"},{"location":"getting-started/#binding-static-methods","text":"TODO: we only have tests for static methods, but class methods should be the same...check it! Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods.","title":"Binding static methods"},{"location":"getting-started/#binding-instance-attributes","text":"Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int One thing to keep in mind is that many Python function can take values of different types. We could bind x with an OCaml function that returns float . In cases where you're binding polymorphic python functions, let the rest of your API guide you on how you'd like to type everything. You can find more info on binding attributes in the attributes & properties section of the manual.","title":"Binding instance attributes"},{"location":"getting-started/#running-pyml_bindgen","text":"Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly. For more info on pyml_bindgen options, see here . I ran lib.ml through ocamlformat so it's easier to read here, but of course, that's optional! $ ocamlformat lib.ml --enable-outside-detected-project And here's the output: let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int val sub : a:int -> b:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs let sub ~a ~b () = let class_ = Py.Module.get (import_module ()) \"Thing\" in let callable = Py.Object.find_attr_string class_ \"sub\" in let kwargs = filter_opt [ Some (\"a\", Py.Int.of_int a); Some (\"b\", Py.Int.of_int b) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Running pyml_bindgen"},{"location":"getting-started/#using-the-generated-module","text":"While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1","title":"Using the generated module"},{"location":"gotchas-bugs/","text":"Gotchas & Known Bugs Nothing to see here... O_o","title":"Gotchas & Known Bugs"},{"location":"gotchas-bugs/#gotchas-known-bugs","text":"Nothing to see here... O_o","title":"Gotchas &amp; Known Bugs"},{"location":"instance-methods/","text":"Instance Methods Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c Rules The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future, but for now, that's how it works :)","title":"Instance Methods"},{"location":"instance-methods/#instance-methods","text":"Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Instance Methods"},{"location":"instance-methods/#rules","text":"The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future, but for now, that's how it works :)","title":"Rules"},{"location":"matplotlib/","text":"Matplotlib Example Okay, okay...this is a sort of fake example. Instead of wrapping a whole bunch of matplotlib code, we're just going to bind a little class that wraps some basic plotting functionality. Just pretend it's some cool coworker's code that you want to access from OCaml :) import matplotlib.pyplot as plt class Plotter: def __init__(self): self.fig, self.ax = plt.subplots() def set_title(self, title): self.ax.set_title(title) def plot(self, x, y, color='tab:blue'): self.ax.plot(x, y, color=color) def save(self, filename): self.fig.savefig(filename) As you can see, it's a simple class that wraps some matplotlib functionality. This example is a bit different than the first one in that no meaningful values are ever returned from the Python methods. It's all just state internal to the Python objects. While you could probably imagine a nicer interface to this class that hides away all the yuck, we are just going to do a straight binding of the methods as they are. Unlike the last example, we are not going to bother with exposing the attributes, since the caller won't need them. We will do all the methods though. Recall that when binding instance methods, the first argument must be t , the last argument must be unit , and the remaining arguments must be named or optional. Value specs __init__ This __init__ function takes no arguments, and returns an instance of Plotter . val __init__ : unit -> t set_title set_title takes a single string argument title , (and self of course, but we don't worry about that from the OCaml side). In Python-land, set_title returns None . In cases like this, we want an OCaml function that returns unit . val set_title : t -> title:string -> unit -> unit We have unit -> unit because the return type is unit , and the final argument of the function needs to be unit . plot The plot function is kind of interesting since it takes an optional argument color . Just because the argument is optional on the Python side doesn't mean that we have to make it optional on the OCaml side, but let's go ahead and make it optional to match the Python API to show you how it's done. (While you could definitely imagine using some sort of variant for a color argument, we will just match the Python and use a string.) val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit Not bad! You just make it like any old OCaml optional argument. save Finally, the save function. Nothing new to talk about so I'll just put down the spec. val save : t -> filename:string -> unit -> unit Put those all in a file called val_specs.txt . Here it is for easy copy-pasting. val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit Run pyml_bindgen Run the following command to generate the OCaml module. $ pyml_bindgen val_specs.txt plotter Plotter --caml-module=Plotter --of-pyo-ret-type=no_check > lib.ml For more info about the options, see the getting started example. For reference, here is the generated source code after running ocamlformat . let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"plotter\" module Plotter : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit end = struct type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let __init__ () = let callable = Py.Module.get (import_module ()) \"Plotter\" in let kwargs = filter_opt [] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let set_title t ~title () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"title\", Py.String.of_string title) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let kwargs = filter_opt [ Some (\"x\", Py.List.of_list_map Py.Float.of_float x); Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let save t ~filename () = let callable = Py.Object.find_attr_string t \"save\" in let kwargs = filter_opt [ Some (\"filename\", Py.String.of_string filename) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Set up the Dune project Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in which you generated the lib.ml file. dune (executable (name run) (libraries pyml)) run.ml open Lib let () = Py.initialize () let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Silly Plot\" () (* See how [color] is optional? *) let () = Plotter.plot plotter ~x ~y () let () = Plotter.save plotter ~filename:\"silly_plot.png\" () let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Orange Plot\" () (* Here, we pass the [color] argument. *) let () = Plotter.plot plotter ~x ~y ~color:\"tab:orange\" () let () = Plotter.save plotter ~filename:\"orange_plot.png\" () And now, go ahead and run that. $ dune exec ./run.exe If all goes well, you should see a couple of PNG files there. Here's what they should look like. The first plot, with default colors: And the orange plot: Pretty cool, right? Wrap up Okay, so this was kind of a goofy example. It's a little artificial, as you probably would want to just bind to matplotlib directly, but to keep things simple, we just used a simple class that binds some matplotlib functionality. It did show you some new stuff, though, and we got to make some cute plots! \ud83d\udcc8 \ud83d\udcca","title":"Matplotlib Example"},{"location":"matplotlib/#matplotlib-example","text":"Okay, okay...this is a sort of fake example. Instead of wrapping a whole bunch of matplotlib code, we're just going to bind a little class that wraps some basic plotting functionality. Just pretend it's some cool coworker's code that you want to access from OCaml :) import matplotlib.pyplot as plt class Plotter: def __init__(self): self.fig, self.ax = plt.subplots() def set_title(self, title): self.ax.set_title(title) def plot(self, x, y, color='tab:blue'): self.ax.plot(x, y, color=color) def save(self, filename): self.fig.savefig(filename) As you can see, it's a simple class that wraps some matplotlib functionality. This example is a bit different than the first one in that no meaningful values are ever returned from the Python methods. It's all just state internal to the Python objects. While you could probably imagine a nicer interface to this class that hides away all the yuck, we are just going to do a straight binding of the methods as they are. Unlike the last example, we are not going to bother with exposing the attributes, since the caller won't need them. We will do all the methods though. Recall that when binding instance methods, the first argument must be t , the last argument must be unit , and the remaining arguments must be named or optional.","title":"Matplotlib Example"},{"location":"matplotlib/#value-specs","text":"","title":"Value specs"},{"location":"matplotlib/#__init__","text":"This __init__ function takes no arguments, and returns an instance of Plotter . val __init__ : unit -> t","title":"__init__"},{"location":"matplotlib/#set_title","text":"set_title takes a single string argument title , (and self of course, but we don't worry about that from the OCaml side). In Python-land, set_title returns None . In cases like this, we want an OCaml function that returns unit . val set_title : t -> title:string -> unit -> unit We have unit -> unit because the return type is unit , and the final argument of the function needs to be unit .","title":"set_title"},{"location":"matplotlib/#plot","text":"The plot function is kind of interesting since it takes an optional argument color . Just because the argument is optional on the Python side doesn't mean that we have to make it optional on the OCaml side, but let's go ahead and make it optional to match the Python API to show you how it's done. (While you could definitely imagine using some sort of variant for a color argument, we will just match the Python and use a string.) val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit Not bad! You just make it like any old OCaml optional argument.","title":"plot"},{"location":"matplotlib/#save","text":"Finally, the save function. Nothing new to talk about so I'll just put down the spec. val save : t -> filename:string -> unit -> unit Put those all in a file called val_specs.txt . Here it is for easy copy-pasting. val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit","title":"save"},{"location":"matplotlib/#run-pyml_bindgen","text":"Run the following command to generate the OCaml module. $ pyml_bindgen val_specs.txt plotter Plotter --caml-module=Plotter --of-pyo-ret-type=no_check > lib.ml For more info about the options, see the getting started example. For reference, here is the generated source code after running ocamlformat . let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"plotter\" module Plotter : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit end = struct type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let __init__ () = let callable = Py.Module.get (import_module ()) \"Plotter\" in let kwargs = filter_opt [] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let set_title t ~title () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"title\", Py.String.of_string title) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let kwargs = filter_opt [ Some (\"x\", Py.List.of_list_map Py.Float.of_float x); Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let save t ~filename () = let callable = Py.Object.find_attr_string t \"save\" in let kwargs = filter_opt [ Some (\"filename\", Py.String.of_string filename) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Run pyml_bindgen"},{"location":"matplotlib/#set-up-the-dune-project","text":"Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in which you generated the lib.ml file. dune (executable (name run) (libraries pyml)) run.ml open Lib let () = Py.initialize () let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Silly Plot\" () (* See how [color] is optional? *) let () = Plotter.plot plotter ~x ~y () let () = Plotter.save plotter ~filename:\"silly_plot.png\" () let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Orange Plot\" () (* Here, we pass the [color] argument. *) let () = Plotter.plot plotter ~x ~y ~color:\"tab:orange\" () let () = Plotter.save plotter ~filename:\"orange_plot.png\" () And now, go ahead and run that. $ dune exec ./run.exe If all goes well, you should see a couple of PNG files there. Here's what they should look like. The first plot, with default colors: And the orange plot: Pretty cool, right?","title":"Set up the Dune project"},{"location":"matplotlib/#wrap-up","text":"Okay, so this was kind of a goofy example. It's a little artificial, as you probably would want to just bind to matplotlib directly, but to keep things simple, we just used a simple class that binds some matplotlib functionality. It did show you some new stuff, though, and we got to make some cute plots! \ud83d\udcc8 \ud83d\udcca","title":"Wrap up"},{"location":"names/","text":"Function & Argument Names You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned above are not allowed. Argument names that start with any of the types mentioned above are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) This will probably be fixed at some point.... Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse.","title":"Function & Argument Names"},{"location":"names/#function-argument-names","text":"You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned above are not allowed. Argument names that start with any of the types mentioned above are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) This will probably be fixed at some point.... Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse.","title":"Function &amp; Argument Names"},{"location":"no-functions/","text":"You can only bind methods, not functions Currently, you can only bind to functions within Python classes (a.k.a., Python methods). At some point, I will change it so you can also bind Python functions that aren't associated with a class. Here's what I mean. A function that isn't associated with a class currently cannot be bound with pyml_bindgen . # Can't bind this def foo(x, y): return x + y But that same function associated with a class, can be bound by pyml_bindgen . # Can bind this class Apple: @staticmethod def foo(x, y): return x + y Let me just be clear that pyml can bind this function just fine, only, you would need to write this binding by hand.","title":"You can only bind methods, not functions"},{"location":"no-functions/#you-can-only-bind-methods-not-functions","text":"Currently, you can only bind to functions within Python classes (a.k.a., Python methods). At some point, I will change it so you can also bind Python functions that aren't associated with a class. Here's what I mean. A function that isn't associated with a class currently cannot be bound with pyml_bindgen . # Can't bind this def foo(x, y): return x + y But that same function associated with a class, can be bound by pyml_bindgen . # Can bind this class Apple: @staticmethod def foo(x, y): return x + y Let me just be clear that pyml can bind this function just fine, only, you would need to write this binding by hand.","title":"You can only bind methods, not functions"},{"location":"static-methods/","text":"Class & Static Methods Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c Rules The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Examples val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int Binding __init__ TODO","title":"Class & Static Methods"},{"location":"static-methods/#class-static-methods","text":"Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Class &amp; Static Methods"},{"location":"static-methods/#rules","text":"The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above .","title":"Rules"},{"location":"static-methods/#examples","text":"val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int","title":"Examples"},{"location":"static-methods/#binding-__init__","text":"TODO","title":"Binding __init__"},{"location":"todo/","text":"To do Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"todo/#to-do","text":"Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"tuples/","text":"Handling Tuples Tuples are sort of weird....As of now, pyml_bindgen can't handle tuples directly :( For now what you need to do is to create a little helper module that \"wraps\" the tuple you need to pass in to Python or return from Python. (Or just write the binding by hand...) Say you need to get an int * string tuple in and out of Python. You should make a module something like this: module rec Tuple_int_string : sig type t val make : int -> string -> t val to_pyobject : t -> Pytypes.pyobject val of_pyobject : Pytypes.pyobject -> t val print_endline : t -> unit end = struct type t = int * string let make i s = (i, s) let to_pyobject (i, s) = Py.Tuple.of_tuple2 (Py.Int.of_int i, Py.String.of_string s) let of_pyobject pyo = let i, s = Py.Tuple.to_tuple2 pyo in (Py.Int.to_int i, Py.String.to_string s) let print_endline (i, s) = print_endline @@ string_of_int i ^ \" \" ^ s end Then you can put that with the code that pyml_bindgen generates for whatever class you're actually trying to bind. Perhaps something like this... module rec Tuple_int_string : sig ... end = struct ... end and My_cool_thing : sig ... val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t ... end (You get the idea.) In the val specs that you write, just refer to the Tuple_int_string module like any other: val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t The key here is to have a module that has working to_pyobject and of_pyobject functions. If these two functions know how to properly get your type/module into and out of Python-land, then it should work :) There is a Cram test here that illustrates this idea. Just note that some of the bash stuff in the run.t file is to automate it, but you'd probably do that part by hand. *Note: At some point, I will work up a full example with tuples and other types that you can't yet deal with directly in pyml_bindgen .","title":"Handling Tuples"},{"location":"tuples/#handling-tuples","text":"Tuples are sort of weird....As of now, pyml_bindgen can't handle tuples directly :( For now what you need to do is to create a little helper module that \"wraps\" the tuple you need to pass in to Python or return from Python. (Or just write the binding by hand...) Say you need to get an int * string tuple in and out of Python. You should make a module something like this: module rec Tuple_int_string : sig type t val make : int -> string -> t val to_pyobject : t -> Pytypes.pyobject val of_pyobject : Pytypes.pyobject -> t val print_endline : t -> unit end = struct type t = int * string let make i s = (i, s) let to_pyobject (i, s) = Py.Tuple.of_tuple2 (Py.Int.of_int i, Py.String.of_string s) let of_pyobject pyo = let i, s = Py.Tuple.to_tuple2 pyo in (Py.Int.to_int i, Py.String.to_string s) let print_endline (i, s) = print_endline @@ string_of_int i ^ \" \" ^ s end Then you can put that with the code that pyml_bindgen generates for whatever class you're actually trying to bind. Perhaps something like this... module rec Tuple_int_string : sig ... end = struct ... end and My_cool_thing : sig ... val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t ... end (You get the idea.) In the val specs that you write, just refer to the Tuple_int_string module like any other: val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t The key here is to have a module that has working to_pyobject and of_pyobject functions. If these two functions know how to properly get your type/module into and out of Python-land, then it should work :) There is a Cram test here that illustrates this idea. Just note that some of the bash stuff in the run.t file is to automate it, but you'd probably do that part by hand. *Note: At some point, I will work up a full example with tuples and other types that you can't yet deal with directly in pyml_bindgen .","title":"Handling Tuples"},{"location":"types/","text":"Types Not all OCaml types are allowed. There are a lot of tests that exercise the rules here. Function arguments For function arguments, you can use float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Apple_pie.t ) Lists of any of the above types Seq.t of any of the above types 'a option , 'a option list , ' a option Seq.t Return types For return types, you can use all of the above types plus unit , and 'a Or_error.t for types 'a other than unit . However, you cannot use unit list or unit Seq.t . This is because I haven't decided the best way to handle unit and None (that's Python's None ) quite yet! Nesting Note: currently, you're not allowed to have nested list , Seq.t , option , or Or_error.t . If you need them, you will have to bind those functions by hand :) Dictionaries TODO mention the hack for Python dictionaries... Tuples Tuples are a little weird in pyml_bindgen . If you need to pass or return tuples to Python functions, see here .","title":"Types"},{"location":"types/#types","text":"Not all OCaml types are allowed. There are a lot of tests that exercise the rules here.","title":"Types"},{"location":"types/#function-arguments","text":"For function arguments, you can use float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Apple_pie.t ) Lists of any of the above types Seq.t of any of the above types 'a option , 'a option list , ' a option Seq.t","title":"Function arguments"},{"location":"types/#return-types","text":"For return types, you can use all of the above types plus unit , and 'a Or_error.t for types 'a other than unit . However, you cannot use unit list or unit Seq.t . This is because I haven't decided the best way to handle unit and None (that's Python's None ) quite yet!","title":"Return types"},{"location":"types/#nesting","text":"Note: currently, you're not allowed to have nested list , Seq.t , option , or Or_error.t . If you need them, you will have to bind those functions by hand :)","title":"Nesting"},{"location":"types/#dictionaries","text":"TODO mention the hack for Python dictionaries...","title":"Dictionaries"},{"location":"types/#tuples","text":"Tuples are a little weird in pyml_bindgen . If you need to pass or return tuples to Python functions, see here .","title":"Tuples"}]}