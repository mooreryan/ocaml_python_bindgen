{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OCaml-Python Bindings Generator Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96 How to get started Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, you can either peruse the rules for writing value specifications that pyml_bindgen can understand, or check out more examples . If you have any questions or issues, please let me know about it on GitHub! Installing pyml_bindgen is a Dune project, so you should be able to clone the repository and build it with dune as long as you have the proper dependencies installed \ud83e\udd1e $ git clone https://github.com/mooreryan/pyml_bindgen.git $ cd pyml_bindgen $ opam install . --deps-only --with-doc --with-test $ dune test && dune build --profile=release && dune install $ pyml_bindgen --help ... help screen should show up ... Quick start pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml $ ocamlformat --enable-outside-detected-project lib.ml And here's the output of the ocamlformat command. module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read. License Software Copyright (c) 2021 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms. Documentation Copyright (c) 2021 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"pyml_bindgen"},{"location":"#ocaml-python-bindings-generator","text":"Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96","title":"OCaml-Python Bindings Generator"},{"location":"#how-to-get-started","text":"Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, you can either peruse the rules for writing value specifications that pyml_bindgen can understand, or check out more examples . If you have any questions or issues, please let me know about it on GitHub!","title":"How to get started"},{"location":"#installing","text":"pyml_bindgen is a Dune project, so you should be able to clone the repository and build it with dune as long as you have the proper dependencies installed \ud83e\udd1e $ git clone https://github.com/mooreryan/pyml_bindgen.git $ cd pyml_bindgen $ opam install . --deps-only --with-doc --with-test $ dune test && dune build --profile=release && dune install $ pyml_bindgen --help ... help screen should show up ...","title":"Installing"},{"location":"#quick-start","text":"pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml $ ocamlformat --enable-outside-detected-project lib.ml And here's the output of the ocamlformat command. module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read.","title":"Quick start"},{"location":"#license","text":"","title":"License"},{"location":"#software","text":"Copyright (c) 2021 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms.","title":"Software"},{"location":"#documentation","text":"Copyright (c) 2021 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"Documentation"},{"location":"attributes/","text":"Attributes & Properties Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a Rules The first and only function argument must be t . The return type can be any of the types mentioned above . Examples val x : t -> int val name : t -> string val price : t -> float","title":"Attributes & Properties"},{"location":"attributes/#attributes-properties","text":"Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a","title":"Attributes &amp; Properties"},{"location":"attributes/#rules","text":"The first and only function argument must be t . The return type can be any of the types mentioned above .","title":"Rules"},{"location":"attributes/#examples","text":"val x : t -> int val name : t -> string val price : t -> float","title":"Examples"},{"location":"dictionaries-2/","text":"Handling Python Dictionaries 2 In the first article about handling Python dictionaries, we wrote a custom Dict module to handle string => string dictionaries. Sometimes when you're binding a large Python project, there will be many different kinds of dictionaries that you need to bind. Rather than write out a module for each key-value type combination we need, this time let's write some functors to help us cut down on the boilerplate. Note: This isn't an introduction to functors, so I won't be explaining too many of the functor specific details! Python code First let's check out the Python code we're going to be binding. silly.py class Inventory: def __init__(self, items): self.d = items def incr(self, item): self.d[item] += 1 def decr(self, item): self.d[item] -= 1 class WeirdDict: def __init__(self, d): self.d = d def add(self, k, v): self.d[k] = v def get(self, k): return self.d[k] As you see, both of these classes are polymorphic with respect to the types they can work with. But for this example, we are going to constrain there types. We will say Inventory is a mapping from strings to integers, and WeirdDict is a mapping from integers to string lists. Here are the value specifications. inventory_val_specs.txt val __init__ : items:String_int_dict.t -> unit -> t option val d : t -> String_int_dict.t option val incr : t -> item:string -> unit -> unit val decr : t -> item:string -> unit -> unit weird_dict_val_specs.txt val __init__ : d:Int_string_list_dict.t -> unit -> t option val d : t -> Int_string_list_dict.t option val add : t -> k:Int.t -> v:String_list.t -> unit -> unit val get : t -> k:Int.t -> unit -> String_list.t A couple notable things here. First, we are putting in some modules that haven't yet been defined: String_int_dict , Int_string_list_dict , and String_list . We will get to them below. You may think, yuck, I don't want to have to deal with a custom type String_list instead of using string list . Don't worry, it will all work out nicely :) Second, we're going to be checking the Python class of everything that goes through an of_pyobject function. (Both in the functors we write, and in the pyml_bindgen app using -r option .) Most of the previous examples haven't bothered with checking the return types to keep things simple. Since this example is more involved anyway, let's go ahead and check the types! Module types & functors Now let's write some functors! Note that I will be making use of features from Base and ppx_jane in this example. Put the code in this section into a file called pyobjectable.ml . Don't forget to put open! Base at the top! Module types First we define a module type called Pyobjectable.S ( S for signature), that has a type t and two functions, of_pyobject and to_pyobject . Note on naming: Pyobjectable => Something that can be turned into a pyobject and back. It's named this way to match the Base naming scheme. module type S = sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject end We will mint another module type that is specific to lists. module type S_list = sig include module type of List type element type t = element list val of_pyobject : Pytypes.pyobject -> element list val to_pyobject : element list -> Pytypes.pyobject end Next, a module type to describe things that can be used as keys in our dictionaries. module type S_dict_key = sig type t [@@deriving hash, sexp] include Comparable.S with type t := t include S with type t := t end The hash , sexp derives plus including Comparable.S allow us to use S_dict_key as a key in both Base.Map and Base.Hashtbl modules. And of course, we also include S because we want it to be pyobjectable. Finally, we make a Pydict module type. This type will be helpful when converting values into and out of pyobjects . module type Pydict = sig type t type key type value type map type hashtbl val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val of_alist : (key * value) list -> t val to_alist : t -> (key * value) list val of_map : map -> t val to_map : t -> map val of_hashtbl : hashtbl -> t val to_hashtbl : t -> hashtbl end In this case, we're saying that we want Pydicts to know how to convert to and from pyobjects , association lists, maps , and hashtbls . Notice how we return t option in the of_pyobject function. This way we can be (a little more) sure that the type is correct. I say a little more because we won't be checking that the types of the keys and values inside the Python dictionary are what we say they are, just that the object is in fact, a Python dictionary. Functors Now let's write two functors that use the above types. First, a functor to make pyobjectable lists ( S_list ): module Make_list (Element : S) : S_list with type element := Element.t = struct include List type t = Element.t list let of_pyobject pyo = Py.List.to_list_map Element.of_pyobject pyo let to_pyobject l = Py.List.of_list_map Element.to_pyobject l end Next, a functor to make Pydicts . module Make_pydict (Key : S_dict_key) (Value : S) : Pydict with type key := Key.t with type value := Value.t with type map := Value.t Map.M(Key).t with type hashtbl := Value.t Hashtbl.M(Key).t = struct type t = Pytypes.pyobject let of_pyobject x = if Py.Dict.check x then Some x else None let to_pyobject x = x let of_alist = Py.Dict.of_bindings_map Key.to_pyobject Value.to_pyobject let to_alist = Py.Dict.to_bindings_map Key.of_pyobject Value.of_pyobject let of_map map = of_alist @@ Map.to_alist map let to_map t = Map.of_alist_exn (module Key) @@ to_alist t let of_hashtbl ht = of_alist @@ Hashtbl.to_alist ht let to_hashtbl t = Hashtbl.of_alist_exn (module Key) @@ to_alist t end Making the needed modules Now that we have our functors, let's make the modules that we specified in the value specs above. Put the following in a file called extensions.ml open! Base module Int = struct include Int let of_pyobject pyo = Py.Int.to_int pyo let to_pyobject i = Py.Int.of_int i end module String = struct include String let of_pyobject pyo = Py.String.to_string pyo let to_pyobject i = Py.String.of_string i end module String_list = Pyobjectable.Make_list (String) module String_int_dict = Pyobjectable.Make_pydict (String) (Int) module Int_string_list_dict = Pyobjectable.Make_pydict (Int) (String_list) A couple of notes here: We're extending Int and String modules so that they will be Pyobjectable . This code we need to write by hand because each basic OCaml type has its own special way of converting to and from a pyobject . You will note that we didn't have to do anything special to ensure that Int was okay to use as a S_dict_key . Since we're using Base, and given the way we wrote the functor, it's all taken care of. String_list is a \"special\" list that knows how to turn string list values to and from pyobjects . Finally, we use our extended Int and String along with String_list to make the *_dict modules that we put in our val specs. Running pyml_bindgen Now that we have all our machinery set up, we're ready to run pyml_bindgen . $ printf \"open Extensions\\n\" > lib.ml $ pyml_bindgen inventory_val_specs.txt silly Inventory --caml-module Inventory \\ | ocamlformat --enable --name=a.ml - >> lib.ml $ printf \"\\n\" >> lib.ml $ pyml_bindgen weird_dict_val_specs.txt silly WeirdDict --caml-module Weird_dict \\ | ocamlformat --enable --name=a.ml - >> lib.ml I interspersed some extra code and spaces between the pyml_bindgen calls using printf . If you need more explanation of the pyml_bindgen options used above, see here . Set up Dune project & run it Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open! Stdio open! Extensions open! Lib let () = Py.initialize () let items = String_int_dict.of_alist [ (\"apple\", 10); (\"pie\", 3) ] let items' = String_int_dict.to_alist items let () = print_s @@ [%sexp_of: (string * int) list] @@ items' let inventory = Option.value_exn (Inventory.__init__ ~items ()) let () = Inventory.incr inventory ~item:\"apple\" () let () = Inventory.decr inventory ~item:\"pie\" () let () = let d = Option.value_exn (Inventory.d inventory) in print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist d (* This is the WRONG WAY to do it... *) let () = let pyo = Inventory.to_pyobject inventory in match String_int_dict.of_pyobject pyo with | Some pyo' -> print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist pyo' | None -> print_endline \"Couldn't convert the pyobject to String_int_dict! Moving on...\" (* Now for the weird dict *) let d = Int_string_list_dict.of_alist [ (1, [ \"apple\"; \"pie\" ]); (2, [ \"is\"; \"good\" ]) ] let weird = Option.value_exn (Weird_dict.__init__ ~d ()) let () = Weird_dict.add weird ~k:3 ~v:[ \"peach\"; \"cobbler\" ] () let () = assert ( List.equal String.equal [ \"peach\"; \"cobbler\" ] (Weird_dict.get weird ~k:3 ())) let () = let d = Option.value_exn (Weird_dict.d weird) in let alist = Int_string_list_dict.to_alist d in print_s @@ [%sexp_of: (int * string list) list] @@ alist Check out how we can use a regular string list for the v argument to Weird_dict.add even though we specified the type as String_list.t . Same thing goes for the return type of the get function. It \"just works\" because of the way we set up the functors earlier. Nice! Run it, and if all goes well, you should see something like this: $ dune exec ./run.exe ((apple 10) (pie 3)) ((apple 11) (pie 2)) Couldn't convert the pyobject to String_int_dict! Moving on... ((1 (apple pie)) (2 (is good)) (3 (peach cobbler))) Wrap-up In this tutorial, we built upon the first dictionary tutorial by using functors to avoid having to write the dictionary helper modules by hand. While you might think functors are overkill for this little example, there are real Python projects that have lots of different dictionaries that you need to use. For example, spaCy has more than 10 different kinds of dictionaries to bind! Writing all that by hand will get tedious :)","title":"Handling Dictionaries 2"},{"location":"dictionaries-2/#handling-python-dictionaries-2","text":"In the first article about handling Python dictionaries, we wrote a custom Dict module to handle string => string dictionaries. Sometimes when you're binding a large Python project, there will be many different kinds of dictionaries that you need to bind. Rather than write out a module for each key-value type combination we need, this time let's write some functors to help us cut down on the boilerplate. Note: This isn't an introduction to functors, so I won't be explaining too many of the functor specific details!","title":"Handling Python Dictionaries 2"},{"location":"dictionaries-2/#python-code","text":"First let's check out the Python code we're going to be binding. silly.py class Inventory: def __init__(self, items): self.d = items def incr(self, item): self.d[item] += 1 def decr(self, item): self.d[item] -= 1 class WeirdDict: def __init__(self, d): self.d = d def add(self, k, v): self.d[k] = v def get(self, k): return self.d[k] As you see, both of these classes are polymorphic with respect to the types they can work with. But for this example, we are going to constrain there types. We will say Inventory is a mapping from strings to integers, and WeirdDict is a mapping from integers to string lists. Here are the value specifications. inventory_val_specs.txt val __init__ : items:String_int_dict.t -> unit -> t option val d : t -> String_int_dict.t option val incr : t -> item:string -> unit -> unit val decr : t -> item:string -> unit -> unit weird_dict_val_specs.txt val __init__ : d:Int_string_list_dict.t -> unit -> t option val d : t -> Int_string_list_dict.t option val add : t -> k:Int.t -> v:String_list.t -> unit -> unit val get : t -> k:Int.t -> unit -> String_list.t A couple notable things here. First, we are putting in some modules that haven't yet been defined: String_int_dict , Int_string_list_dict , and String_list . We will get to them below. You may think, yuck, I don't want to have to deal with a custom type String_list instead of using string list . Don't worry, it will all work out nicely :) Second, we're going to be checking the Python class of everything that goes through an of_pyobject function. (Both in the functors we write, and in the pyml_bindgen app using -r option .) Most of the previous examples haven't bothered with checking the return types to keep things simple. Since this example is more involved anyway, let's go ahead and check the types!","title":"Python code"},{"location":"dictionaries-2/#module-types-functors","text":"Now let's write some functors! Note that I will be making use of features from Base and ppx_jane in this example. Put the code in this section into a file called pyobjectable.ml . Don't forget to put open! Base at the top!","title":"Module types &amp; functors"},{"location":"dictionaries-2/#module-types","text":"First we define a module type called Pyobjectable.S ( S for signature), that has a type t and two functions, of_pyobject and to_pyobject . Note on naming: Pyobjectable => Something that can be turned into a pyobject and back. It's named this way to match the Base naming scheme. module type S = sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject end We will mint another module type that is specific to lists. module type S_list = sig include module type of List type element type t = element list val of_pyobject : Pytypes.pyobject -> element list val to_pyobject : element list -> Pytypes.pyobject end Next, a module type to describe things that can be used as keys in our dictionaries. module type S_dict_key = sig type t [@@deriving hash, sexp] include Comparable.S with type t := t include S with type t := t end The hash , sexp derives plus including Comparable.S allow us to use S_dict_key as a key in both Base.Map and Base.Hashtbl modules. And of course, we also include S because we want it to be pyobjectable. Finally, we make a Pydict module type. This type will be helpful when converting values into and out of pyobjects . module type Pydict = sig type t type key type value type map type hashtbl val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val of_alist : (key * value) list -> t val to_alist : t -> (key * value) list val of_map : map -> t val to_map : t -> map val of_hashtbl : hashtbl -> t val to_hashtbl : t -> hashtbl end In this case, we're saying that we want Pydicts to know how to convert to and from pyobjects , association lists, maps , and hashtbls . Notice how we return t option in the of_pyobject function. This way we can be (a little more) sure that the type is correct. I say a little more because we won't be checking that the types of the keys and values inside the Python dictionary are what we say they are, just that the object is in fact, a Python dictionary.","title":"Module types"},{"location":"dictionaries-2/#functors","text":"Now let's write two functors that use the above types. First, a functor to make pyobjectable lists ( S_list ): module Make_list (Element : S) : S_list with type element := Element.t = struct include List type t = Element.t list let of_pyobject pyo = Py.List.to_list_map Element.of_pyobject pyo let to_pyobject l = Py.List.of_list_map Element.to_pyobject l end Next, a functor to make Pydicts . module Make_pydict (Key : S_dict_key) (Value : S) : Pydict with type key := Key.t with type value := Value.t with type map := Value.t Map.M(Key).t with type hashtbl := Value.t Hashtbl.M(Key).t = struct type t = Pytypes.pyobject let of_pyobject x = if Py.Dict.check x then Some x else None let to_pyobject x = x let of_alist = Py.Dict.of_bindings_map Key.to_pyobject Value.to_pyobject let to_alist = Py.Dict.to_bindings_map Key.of_pyobject Value.of_pyobject let of_map map = of_alist @@ Map.to_alist map let to_map t = Map.of_alist_exn (module Key) @@ to_alist t let of_hashtbl ht = of_alist @@ Hashtbl.to_alist ht let to_hashtbl t = Hashtbl.of_alist_exn (module Key) @@ to_alist t end","title":"Functors"},{"location":"dictionaries-2/#making-the-needed-modules","text":"Now that we have our functors, let's make the modules that we specified in the value specs above. Put the following in a file called extensions.ml open! Base module Int = struct include Int let of_pyobject pyo = Py.Int.to_int pyo let to_pyobject i = Py.Int.of_int i end module String = struct include String let of_pyobject pyo = Py.String.to_string pyo let to_pyobject i = Py.String.of_string i end module String_list = Pyobjectable.Make_list (String) module String_int_dict = Pyobjectable.Make_pydict (String) (Int) module Int_string_list_dict = Pyobjectable.Make_pydict (Int) (String_list) A couple of notes here: We're extending Int and String modules so that they will be Pyobjectable . This code we need to write by hand because each basic OCaml type has its own special way of converting to and from a pyobject . You will note that we didn't have to do anything special to ensure that Int was okay to use as a S_dict_key . Since we're using Base, and given the way we wrote the functor, it's all taken care of. String_list is a \"special\" list that knows how to turn string list values to and from pyobjects . Finally, we use our extended Int and String along with String_list to make the *_dict modules that we put in our val specs.","title":"Making the needed modules"},{"location":"dictionaries-2/#running-pyml_bindgen","text":"Now that we have all our machinery set up, we're ready to run pyml_bindgen . $ printf \"open Extensions\\n\" > lib.ml $ pyml_bindgen inventory_val_specs.txt silly Inventory --caml-module Inventory \\ | ocamlformat --enable --name=a.ml - >> lib.ml $ printf \"\\n\" >> lib.ml $ pyml_bindgen weird_dict_val_specs.txt silly WeirdDict --caml-module Weird_dict \\ | ocamlformat --enable --name=a.ml - >> lib.ml I interspersed some extra code and spaces between the pyml_bindgen calls using printf . If you need more explanation of the pyml_bindgen options used above, see here .","title":"Running pyml_bindgen"},{"location":"dictionaries-2/#set-up-dune-project-run-it","text":"Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open! Stdio open! Extensions open! Lib let () = Py.initialize () let items = String_int_dict.of_alist [ (\"apple\", 10); (\"pie\", 3) ] let items' = String_int_dict.to_alist items let () = print_s @@ [%sexp_of: (string * int) list] @@ items' let inventory = Option.value_exn (Inventory.__init__ ~items ()) let () = Inventory.incr inventory ~item:\"apple\" () let () = Inventory.decr inventory ~item:\"pie\" () let () = let d = Option.value_exn (Inventory.d inventory) in print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist d (* This is the WRONG WAY to do it... *) let () = let pyo = Inventory.to_pyobject inventory in match String_int_dict.of_pyobject pyo with | Some pyo' -> print_s @@ [%sexp_of: (string * int) list] @@ String_int_dict.to_alist pyo' | None -> print_endline \"Couldn't convert the pyobject to String_int_dict! Moving on...\" (* Now for the weird dict *) let d = Int_string_list_dict.of_alist [ (1, [ \"apple\"; \"pie\" ]); (2, [ \"is\"; \"good\" ]) ] let weird = Option.value_exn (Weird_dict.__init__ ~d ()) let () = Weird_dict.add weird ~k:3 ~v:[ \"peach\"; \"cobbler\" ] () let () = assert ( List.equal String.equal [ \"peach\"; \"cobbler\" ] (Weird_dict.get weird ~k:3 ())) let () = let d = Option.value_exn (Weird_dict.d weird) in let alist = Int_string_list_dict.to_alist d in print_s @@ [%sexp_of: (int * string list) list] @@ alist Check out how we can use a regular string list for the v argument to Weird_dict.add even though we specified the type as String_list.t . Same thing goes for the return type of the get function. It \"just works\" because of the way we set up the functors earlier. Nice! Run it, and if all goes well, you should see something like this: $ dune exec ./run.exe ((apple 10) (pie 3)) ((apple 11) (pie 2)) Couldn't convert the pyobject to String_int_dict! Moving on... ((1 (apple pie)) (2 (is good)) (3 (peach cobbler)))","title":"Set up Dune project &amp; run it"},{"location":"dictionaries-2/#wrap-up","text":"In this tutorial, we built upon the first dictionary tutorial by using functors to avoid having to write the dictionary helper modules by hand. While you might think functors are overkill for this little example, there are real Python projects that have lots of different dictionaries that you need to use. For example, spaCy has more than 10 different kinds of dictionaries to bind! Writing all that by hand will get tedious :)","title":"Wrap-up"},{"location":"dictionaries/","text":"Handling Python Dictionaries Note: This is a simpler way to handle dictionaries. For a more general, but more complicated way, see here . Let's see how to handle Python Dictionaries . For now, you need to define a module that has a couple of functions. For now, we will call it Dict . You can use a signature or mli file if you want, but to keep it simple, we will leave it out for now. Stick the following code in a file called dict.ml type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x Technically, that would be all you need, but it's not very easy to work with...you would have to create all your own pyobjects by hand. Yuck! The next thing you need is to decide what kind of interface you want your Dict.t to have. By that I just mean that it would be nice to have a convenient way to get standard \"dictionary-like\" types into Dict.t . In this tutorial, we will look at three: an association list, and Base's Map and Hashtbl . Of course, you may want to use something different, and that will work just fine after you see how to do it. Write val specs But first we should look at the Python code we are planning to bind. silly_map.py def add(d, k, v): d[k] = v def get(d, k): return d[k] Just two functions to define a weird little map module: add and get , both of which take a dictionary as their first argument. The Python dictionary can have pretty much any types for keys and values, but we are going to use it as a string => string map. You should choose whatever types make sense for your particular use case. Here are the value specs to bind these functions. val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string Generate bindings Now, let's generate our library code. $ pyml_bindgen val_specs.txt silly_map NA \\ --caml-module=Silly_map -a module -r no_check \\ | ocamlformat --enable - --name=x.ml \\ > lib.ml See that weird NA in the command? That's because you currently have to pass in a Python class name, even if you are binding module functions. The generated OCaml module will be Silly_map . The other flags specify that we want to bind module associated code and not code associated with a class ( -a module ), and that we don't want to check the results of any converting code ( -r no_check ). *Note: For more info on pyml_bindgen CLI args, see here . Here's what the generated code looks like: module Silly_map : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"silly_map\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let add ~d ~k ~v () = let callable = Py.Module.get (import_module ()) \"add\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k); Some (\"v\", Py.String.of_string v); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let get ~d ~k () = let callable = Py.Module.get (import_module ()) \"get\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k) ] in Py.String.to_string @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Finish the Dict module Okay, now that we know a little more about the Python code and our desired interface for the Silly_map module, let's return to the Dict module and fill it out. Here's the whole thing. Jump down for some explanations. open! Base type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x let empty () = Py.Dict.create () let of_alist x = Py.Dict.of_bindings_map Py.String.of_string Py.String.of_string x let to_alist x = Py.Dict.to_bindings_map Py.String.to_string Py.String.to_string x let of_map x = of_alist @@ Map.to_alist x let to_map x = Map.of_alist_exn (module String) @@ to_alist x let of_hashtbl x = of_alist @@ Hashtbl.to_alist x let to_hashtbl x = Hashtbl.of_alist_exn (module String) @@ to_alist x let print_endline x = Stdio.print_endline @@ Sexp.to_string_hum @@ [%sexp_of: (string * string) list] @@ to_alist x of_alist and to_alist let us connect the Dict module with association lists. The Py.Dict.of_bindings_map function takes two functions used to convert OCaml values to Python values, and the association list. In this case, we're passing in strings, so we use Py.String.of_string to convert an OCaml string to a Pytypes.pyobject . The to_bindings_map works in an analogous way. Note: For more info on writing pyml bindings, check out the py.mli signature file. Next, the of/to_map and of/to_hashtbl functions are pretty simple. Both Map and Hashtbl modules have a of/to_alist functions. So, we just call the function to convert to/from an association list, then call the matching Dict.of/to_alist function. Finally, I threw in a printing function that uses sexp_of to convert the alist to a sexp, then print it. Setup Dune project & run Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open Lib open Stdio let () = Py.initialize () let d = Dict.empty () let () = Silly_map.add ~d ~k:\"apple\" ~v:\"pie\" () let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = print_endline @@ Silly_map.get ~d ~k:\"apple\" () let () = print_endline @@ Silly_map.get ~d ~k:\"is\" () (* Another example. *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let () = print_endline @@ Silly_map.get ~d:(Dict.of_alist [ (\"apple\", \"pie\") ]) ~k:\"apple\" () (* Base.Map *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let m = Map.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_map m let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d (* Base.Hashtbl *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let ht = Hashtbl.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_hashtbl ht let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d Run it like so: $ dune exec ./run.exe If all goes well, you should see some zany output like this: pie good ~~~~~~~~~~~~~~~~~~~~~~~~~~ pie ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good)) ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good)) Wrap-up In this tutorial, we went over a couple of ways to handle Python Dictionaries. A lot of times, you will need to pass a dictionary to a Python function or return one from a Python function. Hopefully, you have a good idea of how to do this now!","title":"Handling Dictionaries"},{"location":"dictionaries/#handling-python-dictionaries","text":"Note: This is a simpler way to handle dictionaries. For a more general, but more complicated way, see here . Let's see how to handle Python Dictionaries . For now, you need to define a module that has a couple of functions. For now, we will call it Dict . You can use a signature or mli file if you want, but to keep it simple, we will leave it out for now. Stick the following code in a file called dict.ml type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x Technically, that would be all you need, but it's not very easy to work with...you would have to create all your own pyobjects by hand. Yuck! The next thing you need is to decide what kind of interface you want your Dict.t to have. By that I just mean that it would be nice to have a convenient way to get standard \"dictionary-like\" types into Dict.t . In this tutorial, we will look at three: an association list, and Base's Map and Hashtbl . Of course, you may want to use something different, and that will work just fine after you see how to do it.","title":"Handling Python Dictionaries"},{"location":"dictionaries/#write-val-specs","text":"But first we should look at the Python code we are planning to bind. silly_map.py def add(d, k, v): d[k] = v def get(d, k): return d[k] Just two functions to define a weird little map module: add and get , both of which take a dictionary as their first argument. The Python dictionary can have pretty much any types for keys and values, but we are going to use it as a string => string map. You should choose whatever types make sense for your particular use case. Here are the value specs to bind these functions. val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string","title":"Write val specs"},{"location":"dictionaries/#generate-bindings","text":"Now, let's generate our library code. $ pyml_bindgen val_specs.txt silly_map NA \\ --caml-module=Silly_map -a module -r no_check \\ | ocamlformat --enable - --name=x.ml \\ > lib.ml See that weird NA in the command? That's because you currently have to pass in a Python class name, even if you are binding module functions. The generated OCaml module will be Silly_map . The other flags specify that we want to bind module associated code and not code associated with a class ( -a module ), and that we don't want to check the results of any converting code ( -r no_check ). *Note: For more info on pyml_bindgen CLI args, see here . Here's what the generated code looks like: module Silly_map : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val add : d:Dict.t -> k:string -> v:string -> unit -> unit val get : d:Dict.t -> k:string -> unit -> string end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"silly_map\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let add ~d ~k ~v () = let callable = Py.Module.get (import_module ()) \"add\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k); Some (\"v\", Py.String.of_string v); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let get ~d ~k () = let callable = Py.Module.get (import_module ()) \"get\" in let kwargs = filter_opt [ Some (\"d\", Dict.to_pyobject d); Some (\"k\", Py.String.of_string k) ] in Py.String.to_string @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Generate bindings"},{"location":"dictionaries/#finish-the-dict-module","text":"Okay, now that we know a little more about the Python code and our desired interface for the Silly_map module, let's return to the Dict module and fill it out. Here's the whole thing. Jump down for some explanations. open! Base type t = Pytypes.pyobject let to_pyobject x = x let of_pyobject x = x let empty () = Py.Dict.create () let of_alist x = Py.Dict.of_bindings_map Py.String.of_string Py.String.of_string x let to_alist x = Py.Dict.to_bindings_map Py.String.to_string Py.String.to_string x let of_map x = of_alist @@ Map.to_alist x let to_map x = Map.of_alist_exn (module String) @@ to_alist x let of_hashtbl x = of_alist @@ Hashtbl.to_alist x let to_hashtbl x = Hashtbl.of_alist_exn (module String) @@ to_alist x let print_endline x = Stdio.print_endline @@ Sexp.to_string_hum @@ [%sexp_of: (string * string) list] @@ to_alist x of_alist and to_alist let us connect the Dict module with association lists. The Py.Dict.of_bindings_map function takes two functions used to convert OCaml values to Python values, and the association list. In this case, we're passing in strings, so we use Py.String.of_string to convert an OCaml string to a Pytypes.pyobject . The to_bindings_map works in an analogous way. Note: For more info on writing pyml bindings, check out the py.mli signature file. Next, the of/to_map and of/to_hashtbl functions are pretty simple. Both Map and Hashtbl modules have a of/to_alist functions. So, we just call the function to convert to/from an association list, then call the matching Dict.of/to_alist function. Finally, I threw in a printing function that uses sexp_of to convert the alist to a sexp, then print it.","title":"Finish the Dict module"},{"location":"dictionaries/#setup-dune-project-run","text":"Now we're ready to set up a Dune project and write a driver to run the generated code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries base pyml stdio) (preprocess (pps ppx_jane))) run.ml open! Base open Lib open Stdio let () = Py.initialize () let d = Dict.empty () let () = Silly_map.add ~d ~k:\"apple\" ~v:\"pie\" () let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = print_endline @@ Silly_map.get ~d ~k:\"apple\" () let () = print_endline @@ Silly_map.get ~d ~k:\"is\" () (* Another example. *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let () = print_endline @@ Silly_map.get ~d:(Dict.of_alist [ (\"apple\", \"pie\") ]) ~k:\"apple\" () (* Base.Map *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let m = Map.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_map m let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d (* Base.Hashtbl *) let () = print_endline \"~~~~~~~~~~~~~~~~~~~~~~~~~~\" let ht = Hashtbl.of_alist_exn (module String) [ (\"apple\", \"pie\") ] let d = Dict.of_hashtbl ht let () = Silly_map.add ~d ~k:\"is\" ~v:\"good\" () let () = Dict.print_endline d Run it like so: $ dune exec ./run.exe If all goes well, you should see some zany output like this: pie good ~~~~~~~~~~~~~~~~~~~~~~~~~~ pie ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good)) ~~~~~~~~~~~~~~~~~~~~~~~~~~ ((apple pie) (is good))","title":"Setup Dune project &amp; run"},{"location":"dictionaries/#wrap-up","text":"In this tutorial, we went over a couple of ways to handle Python Dictionaries. A lot of times, you will need to pass a dictionary to a Python function or return one from a Python function. Hopefully, you have a good idea of how to do this now!","title":"Wrap-up"},{"location":"getting-started/","text":"Getting Started To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do the obvious thing write OCaml functions with the same names as the Python methods. You also need to use named (or optional) arguments. Binding constructors __init__ in Python constructs an instance of the class. While you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit . See here for more about why that is. Binding instance methods Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods. Binding static methods TODO: we only have tests for static methods, but class methods should be the same...check it! Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods. Binding instance attributes Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int One thing to keep in mind is that many Python function can take values of different types. We could bind x with an OCaml function that returns float . In cases where you're binding polymorphic python functions, let the rest of your API guide you on how you'd like to type everything. You can find more info on binding attributes in the attributes & properties section of the manual. Running pyml_bindgen Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly. For more info on pyml_bindgen options, see here . I ran lib.ml through ocamlformat so it's easier to read here, but of course, that's optional! $ ocamlformat lib.ml --enable-outside-detected-project And here's the output: module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int val sub : a:int -> b:int -> unit -> int end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs let sub ~a ~b () = let class_ = Py.Module.get (import_module ()) \"Thing\" in let callable = Py.Object.find_attr_string class_ \"sub\" in let kwargs = filter_opt [ Some (\"a\", Py.Int.of_int a); Some (\"b\", Py.Int.of_int b) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Using the generated module While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do the obvious thing write OCaml functions with the same names as the Python methods. You also need to use named (or optional) arguments.","title":"Getting Started"},{"location":"getting-started/#binding-constructors","text":"__init__ in Python constructs an instance of the class. While you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit . See here for more about why that is.","title":"Binding constructors"},{"location":"getting-started/#binding-instance-methods","text":"Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods.","title":"Binding instance methods"},{"location":"getting-started/#binding-static-methods","text":"TODO: we only have tests for static methods, but class methods should be the same...check it! Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods.","title":"Binding static methods"},{"location":"getting-started/#binding-instance-attributes","text":"Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int One thing to keep in mind is that many Python function can take values of different types. We could bind x with an OCaml function that returns float . In cases where you're binding polymorphic python functions, let the rest of your API guide you on how you'd like to type everything. You can find more info on binding attributes in the attributes & properties section of the manual.","title":"Binding instance attributes"},{"location":"getting-started/#running-pyml_bindgen","text":"Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly. For more info on pyml_bindgen options, see here . I ran lib.ml through ocamlformat so it's easier to read here, but of course, that's optional! $ ocamlformat lib.ml --enable-outside-detected-project And here's the output: module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int val sub : a:int -> b:int -> unit -> int end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs let sub ~a ~b () = let class_ = Py.Module.get (import_module ()) \"Thing\" in let callable = Py.Object.find_attr_string class_ \"sub\" in let kwargs = filter_opt [ Some (\"a\", Py.Int.of_int a); Some (\"b\", Py.Int.of_int b) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Running pyml_bindgen"},{"location":"getting-started/#using-the-generated-module","text":"While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1","title":"Using the generated module"},{"location":"gotchas-bugs/","text":"Gotchas & Known Bugs Nothing to see here... O_o","title":"Gotchas & Known Bugs"},{"location":"gotchas-bugs/#gotchas-known-bugs","text":"Nothing to see here... O_o","title":"Gotchas &amp; Known Bugs"},{"location":"instance-methods/","text":"Instance Methods Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c Rules The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future, but for now, that's how it works :)","title":"Instance Methods"},{"location":"instance-methods/#instance-methods","text":"Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Instance Methods"},{"location":"instance-methods/#rules","text":"The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future, but for now, that's how it works :)","title":"Rules"},{"location":"matplotlib-2/","text":"Another matplotlib example Let's take another look at matplotlib . This one will be a little different in that we will generate direct bindings for a couple of matplotlib classes and module functions. Axes Figure matplotlib.pyplot.subplots This example will also show you some of the current limitations of pyml_bindgen :) Value specs For this example, we won't bother binding all the arguments that these methods take since we won't be using them. For each of these, I will put down the arguments as shown in the matplotlib docs, the follow it with the OCaml value spec we will use. Axes.set_title ( docs ) Python: Axes.set_title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs) OCaml: val set_title : t -> label:string -> unit -> unit Axes.plot ( docs ) Python: Axes.plot(*args, scalex=True, scaley=True, data=None, **kwargs) OCaml: val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit This value spec will generate an Axes.plot function actually has a bug. If you check the docs, you can't actually pass x and y as keyword arguments. Oops! You have to go in and edit the binding by hand. Below, I will show a patch file with the changes you need to make. You may be thinking, well, that's pretty annoying...I agree! For this function, I would probably just write it by hand from the start. I'm showing it here partly as a reminder that I want to change the behaviour of pyml_bindgen in a future release to handle methods like this one. But for now, you have to deal with it yourself :) Note that while we used float list for x and y here, you may want to use float array instead. Figure.savefig ( docs ) savefig(fname, *, transparent=None, **kwargs) val savefig : t -> fname:string -> unit -> unit Generating Axes & Figure modules Let's go over the arguments and options for pyml_bindgen that we will need. Note that we need to specify the correct Python module from which the Axes and Figure classes come. For Axes , that's matplotlib.axes . For Figure , that's matplotlib.figure . We use --caml-module option again to tell pyml_bindgen to generate the module signature as well as the implementation. We use -a class to specify that we want to generate class-associated methods. Note that this is the default option. For both invocations, we pipe the output directly to ocamlformat . Run pyml_bindgen Here are the commands. pyml_bindgen axes_specs.txt matplotlib.axes Axes --caml-module Axes -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ > py_class.ml printf \"\\n\" >> py_class.ml pyml_bindgen figure_specs.txt matplotlib.figure Figure --caml-module Figure -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ >> py_class.ml Patch the file Above, I mentioned that you would need to change the implementation for the Axes module a bit. Here is the patch for the lines you need to change. Here is a patch showing the change I mean --- py_class_bug.ml 2021-10-20 20:21:00.000000000 -0400 +++ py_class.ml 2021-10-20 20:21:00.000000000 -0400 @@ -30,17 +30,21 @@ let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in + let args = + [| + Py.List.of_list_map Py.Float.of_float x; + Py.List.of_list_map Py.Float.of_float y; + |] + in let kwargs = filter_opt [ - Some (\"x\", Py.List.of_list_map Py.Float.of_float x); - Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in - ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs + ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig Generated output Here's the whole of the generated output including the patch. module Axes : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val set_title : t -> label:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.axes\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Axes\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let set_title t ~label () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"label\", Py.String.of_string label) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let args = [| Py.List.of_list_map Py.Float.of_float x; Py.List.of_list_map Py.Float.of_float y; |] in let kwargs = filter_opt [ (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val savefig : t -> fname:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.figure\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Figure\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let savefig t ~fname () = let callable = Py.Object.find_attr_string t \"savefig\" in let kwargs = filter_opt [ Some (\"fname\", Py.String.of_string fname) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Write the Pyplot module For a little variety, and because we don't need any of the extra stuff that pyml_bindgen generates (again, you will be able to control this eventually), let's write this one by hand. Then you can make a pyplot.ml file open Py_class let import_module () = Py.Import.import_module \"matplotlib.pyplot\" let subplots () = let callable = Py.Module.get (import_module ()) \"subplots\" in let args = [||] in let kwargs = [] in let tup = Py.Callable.to_function_with_keywords callable args kwargs in let fig, ax = Py.Tuple.to_tuple2 tup in match (Figure.of_pyobject fig, Axes.of_pyobject ax) with | Some f, Some a -> Some (f, a) | Some _, None | None, Some _ | None, None -> None Note that there are more compact ways to write this with pyml , but we will leave it like this to keep it similar to the rest of the generated functions. Set up the Dune project and run it Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries pyml)) run.ml open Py_class let () = Py.initialize () let figure, axes = match Pyplot.subplots () with | Some (fig, ax) -> (fig, ax) | None -> failwith \"Failed to make figure and axes!\" let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let () = Axes.set_title axes ~label:\"Brown Plot\" () let () = Axes.plot axes ~x ~y ~color:\"tab:brown\" () let () = Figure.savefig figure ~fname:\"brown_plot.png\" () Run it like so: $ dune exec ./run.exe If all goes well, you should see a nice, brown line plot: Wrap up In this tutorial, we generating bindings for a couple of matplotlib classes and functions. You saw how to combine multiple generated modules as well as some of the little workarounds you still have to do. Like all the examples so far, we're only binding a couple of classes & functions. For such a small thing, feel free to write your bindings by hand. These two classes alone have tons of functions though, so if you were binding them all, that would be a pain to write by hand!","title":"Matplotlib Example 2"},{"location":"matplotlib-2/#another-matplotlib-example","text":"Let's take another look at matplotlib . This one will be a little different in that we will generate direct bindings for a couple of matplotlib classes and module functions. Axes Figure matplotlib.pyplot.subplots This example will also show you some of the current limitations of pyml_bindgen :)","title":"Another matplotlib example"},{"location":"matplotlib-2/#value-specs","text":"For this example, we won't bother binding all the arguments that these methods take since we won't be using them. For each of these, I will put down the arguments as shown in the matplotlib docs, the follow it with the OCaml value spec we will use.","title":"Value specs"},{"location":"matplotlib-2/#axesset_title","text":"( docs ) Python: Axes.set_title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs) OCaml: val set_title : t -> label:string -> unit -> unit","title":"Axes.set_title"},{"location":"matplotlib-2/#axesplot","text":"( docs ) Python: Axes.plot(*args, scalex=True, scaley=True, data=None, **kwargs) OCaml: val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit This value spec will generate an Axes.plot function actually has a bug. If you check the docs, you can't actually pass x and y as keyword arguments. Oops! You have to go in and edit the binding by hand. Below, I will show a patch file with the changes you need to make. You may be thinking, well, that's pretty annoying...I agree! For this function, I would probably just write it by hand from the start. I'm showing it here partly as a reminder that I want to change the behaviour of pyml_bindgen in a future release to handle methods like this one. But for now, you have to deal with it yourself :) Note that while we used float list for x and y here, you may want to use float array instead.","title":"Axes.plot"},{"location":"matplotlib-2/#figuresavefig","text":"( docs ) savefig(fname, *, transparent=None, **kwargs) val savefig : t -> fname:string -> unit -> unit","title":"Figure.savefig"},{"location":"matplotlib-2/#generating-axes-figure-modules","text":"Let's go over the arguments and options for pyml_bindgen that we will need. Note that we need to specify the correct Python module from which the Axes and Figure classes come. For Axes , that's matplotlib.axes . For Figure , that's matplotlib.figure . We use --caml-module option again to tell pyml_bindgen to generate the module signature as well as the implementation. We use -a class to specify that we want to generate class-associated methods. Note that this is the default option. For both invocations, we pipe the output directly to ocamlformat .","title":"Generating Axes &amp; Figure modules"},{"location":"matplotlib-2/#run-pyml_bindgen","text":"Here are the commands. pyml_bindgen axes_specs.txt matplotlib.axes Axes --caml-module Axes -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ > py_class.ml printf \"\\n\" >> py_class.ml pyml_bindgen figure_specs.txt matplotlib.figure Figure --caml-module Figure -a class \\ | ocamlformat --enable-outside-detected-project --name=a.ml - \\ >> py_class.ml","title":"Run pyml_bindgen"},{"location":"matplotlib-2/#patch-the-file","text":"Above, I mentioned that you would need to change the implementation for the Axes module a bit. Here is the patch for the lines you need to change. Here is a patch showing the change I mean --- py_class_bug.ml 2021-10-20 20:21:00.000000000 -0400 +++ py_class.ml 2021-10-20 20:21:00.000000000 -0400 @@ -30,17 +30,21 @@ let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in + let args = + [| + Py.List.of_list_map Py.Float.of_float x; + Py.List.of_list_map Py.Float.of_float y; + |] + in let kwargs = filter_opt [ - Some (\"x\", Py.List.of_list_map Py.Float.of_float x); - Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in - ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs + ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig","title":"Patch the file"},{"location":"matplotlib-2/#generated-output","text":"Here's the whole of the generated output including the patch. module Axes : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val set_title : t -> label:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.axes\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Axes\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let set_title t ~label () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"label\", Py.String.of_string label) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let args = [| Py.List.of_list_map Py.Float.of_float x; Py.List.of_list_map Py.Float.of_float y; |] in let kwargs = filter_opt [ (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable args kwargs end module Figure : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val savefig : t -> fname:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"matplotlib.figure\" type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Figure\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let savefig t ~fname () = let callable = Py.Object.find_attr_string t \"savefig\" in let kwargs = filter_opt [ Some (\"fname\", Py.String.of_string fname) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Generated output"},{"location":"matplotlib-2/#write-the-pyplot-module","text":"For a little variety, and because we don't need any of the extra stuff that pyml_bindgen generates (again, you will be able to control this eventually), let's write this one by hand. Then you can make a pyplot.ml file open Py_class let import_module () = Py.Import.import_module \"matplotlib.pyplot\" let subplots () = let callable = Py.Module.get (import_module ()) \"subplots\" in let args = [||] in let kwargs = [] in let tup = Py.Callable.to_function_with_keywords callable args kwargs in let fig, ax = Py.Tuple.to_tuple2 tup in match (Figure.of_pyobject fig, Axes.of_pyobject ax) with | Some f, Some a -> Some (f, a) | Some _, None | None, Some _ | None, None -> None Note that there are more compact ways to write this with pyml , but we will leave it like this to keep it similar to the rest of the generated functions.","title":"Write the Pyplot module"},{"location":"matplotlib-2/#set-up-the-dune-project-and-run-it","text":"Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in as the other files. dune (executable (name run) (libraries pyml)) run.ml open Py_class let () = Py.initialize () let figure, axes = match Pyplot.subplots () with | Some (fig, ax) -> (fig, ax) | None -> failwith \"Failed to make figure and axes!\" let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let () = Axes.set_title axes ~label:\"Brown Plot\" () let () = Axes.plot axes ~x ~y ~color:\"tab:brown\" () let () = Figure.savefig figure ~fname:\"brown_plot.png\" () Run it like so: $ dune exec ./run.exe If all goes well, you should see a nice, brown line plot:","title":"Set up the Dune project and run it"},{"location":"matplotlib-2/#wrap-up","text":"In this tutorial, we generating bindings for a couple of matplotlib classes and functions. You saw how to combine multiple generated modules as well as some of the little workarounds you still have to do. Like all the examples so far, we're only binding a couple of classes & functions. For such a small thing, feel free to write your bindings by hand. These two classes alone have tons of functions though, so if you were binding them all, that would be a pain to write by hand!","title":"Wrap up"},{"location":"matplotlib/","text":"Matplotlib Example Okay, okay...this is a sort of fake example. Instead of wrapping a whole bunch of matplotlib code, we're just going to bind a little class that wraps some basic plotting functionality. Just pretend it's some cool coworker's code that you want to access from OCaml :) import matplotlib.pyplot as plt class Plotter: def __init__(self): self.fig, self.ax = plt.subplots() def set_title(self, title): self.ax.set_title(title) def plot(self, x, y, color='tab:blue'): self.ax.plot(x, y, color=color) def save(self, filename): self.fig.savefig(filename) As you can see, it's a simple class that wraps some matplotlib functionality. This example is a bit different than the first one in that no meaningful values are ever returned from the Python methods. It's all just state internal to the Python objects. While you could probably imagine a nicer interface to this class that hides away all the yuck, we are just going to do a straight binding of the methods as they are. Unlike the last example, we are not going to bother with exposing the attributes, since the caller won't need them. We will do all the methods though. Recall that when binding instance methods, the first argument must be t , the last argument must be unit , and the remaining arguments must be named or optional. Value specs __init__ This __init__ function takes no arguments, and returns an instance of Plotter . val __init__ : unit -> t set_title set_title takes a single string argument title , (and self of course, but we don't worry about that from the OCaml side). In Python-land, set_title returns None . In cases like this, we want an OCaml function that returns unit . val set_title : t -> title:string -> unit -> unit We have unit -> unit because the return type is unit , and the final argument of the function needs to be unit . plot The plot function is kind of interesting since it takes an optional argument color . Just because the argument is optional on the Python side doesn't mean that we have to make it optional on the OCaml side, but let's go ahead and make it optional to match the Python API to show you how it's done. (While you could definitely imagine using some sort of variant for a color argument, we will just match the Python and use a string.) val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit Not bad! You just make it like any old OCaml optional argument. Note that while we used float list for x and y here, you may want to use float array instead. save Finally, the save function. Nothing new to talk about so I'll just put down the spec. val save : t -> filename:string -> unit -> unit Put those all in a file called val_specs.txt . Here it is for easy copy-pasting. val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit Run pyml_bindgen Run the following command to generate the OCaml module. $ pyml_bindgen val_specs.txt plotter Plotter --caml-module=Plotter --of-pyo-ret-type=no_check > lib.ml For more info about the options, see the getting started example. For reference, here is the generated source code after running ocamlformat . module Plotter : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"plotter\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let __init__ () = let callable = Py.Module.get (import_module ()) \"Plotter\" in let kwargs = filter_opt [] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let set_title t ~title () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"title\", Py.String.of_string title) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let kwargs = filter_opt [ Some (\"x\", Py.List.of_list_map Py.Float.of_float x); Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let save t ~filename () = let callable = Py.Object.find_attr_string t \"save\" in let kwargs = filter_opt [ Some (\"filename\", Py.String.of_string filename) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Set up the Dune project Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in which you generated the lib.ml file. dune (executable (name run) (libraries pyml)) run.ml open Lib let () = Py.initialize () let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Silly Plot\" () (* See how [color] is optional? *) let () = Plotter.plot plotter ~x ~y () let () = Plotter.save plotter ~filename:\"silly_plot.png\" () let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Orange Plot\" () (* Here, we pass the [color] argument. *) let () = Plotter.plot plotter ~x ~y ~color:\"tab:orange\" () let () = Plotter.save plotter ~filename:\"orange_plot.png\" () And now, go ahead and run that. $ dune exec ./run.exe If all goes well, you should see a couple of PNG files there. Here's what they should look like. The first plot, with default colors: And the orange plot: Pretty cool, right? Wrap up Okay, so this was kind of a goofy example. It's a little artificial, as you probably would want to just bind to matplotlib directly, but to keep things simple, we just used a simple class that binds some matplotlib functionality. It did show you some new stuff, though, and we got to make some cute plots! \ud83d\udcc8 \ud83d\udcca","title":"Matplotlib Example"},{"location":"matplotlib/#matplotlib-example","text":"Okay, okay...this is a sort of fake example. Instead of wrapping a whole bunch of matplotlib code, we're just going to bind a little class that wraps some basic plotting functionality. Just pretend it's some cool coworker's code that you want to access from OCaml :) import matplotlib.pyplot as plt class Plotter: def __init__(self): self.fig, self.ax = plt.subplots() def set_title(self, title): self.ax.set_title(title) def plot(self, x, y, color='tab:blue'): self.ax.plot(x, y, color=color) def save(self, filename): self.fig.savefig(filename) As you can see, it's a simple class that wraps some matplotlib functionality. This example is a bit different than the first one in that no meaningful values are ever returned from the Python methods. It's all just state internal to the Python objects. While you could probably imagine a nicer interface to this class that hides away all the yuck, we are just going to do a straight binding of the methods as they are. Unlike the last example, we are not going to bother with exposing the attributes, since the caller won't need them. We will do all the methods though. Recall that when binding instance methods, the first argument must be t , the last argument must be unit , and the remaining arguments must be named or optional.","title":"Matplotlib Example"},{"location":"matplotlib/#value-specs","text":"","title":"Value specs"},{"location":"matplotlib/#__init__","text":"This __init__ function takes no arguments, and returns an instance of Plotter . val __init__ : unit -> t","title":"__init__"},{"location":"matplotlib/#set_title","text":"set_title takes a single string argument title , (and self of course, but we don't worry about that from the OCaml side). In Python-land, set_title returns None . In cases like this, we want an OCaml function that returns unit . val set_title : t -> title:string -> unit -> unit We have unit -> unit because the return type is unit , and the final argument of the function needs to be unit .","title":"set_title"},{"location":"matplotlib/#plot","text":"The plot function is kind of interesting since it takes an optional argument color . Just because the argument is optional on the Python side doesn't mean that we have to make it optional on the OCaml side, but let's go ahead and make it optional to match the Python API to show you how it's done. (While you could definitely imagine using some sort of variant for a color argument, we will just match the Python and use a string.) val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit Not bad! You just make it like any old OCaml optional argument. Note that while we used float list for x and y here, you may want to use float array instead.","title":"plot"},{"location":"matplotlib/#save","text":"Finally, the save function. Nothing new to talk about so I'll just put down the spec. val save : t -> filename:string -> unit -> unit Put those all in a file called val_specs.txt . Here it is for easy copy-pasting. val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit","title":"save"},{"location":"matplotlib/#run-pyml_bindgen","text":"Run the following command to generate the OCaml module. $ pyml_bindgen val_specs.txt plotter Plotter --caml-module=Plotter --of-pyo-ret-type=no_check > lib.ml For more info about the options, see the getting started example. For reference, here is the generated source code after running ocamlformat . module Plotter : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val __init__ : unit -> t val set_title : t -> title:string -> unit -> unit val plot : t -> x:float list -> y:float list -> ?color:string -> unit -> unit val save : t -> filename:string -> unit -> unit end = struct let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"plotter\" type t = Pytypes.pyobject let of_pyobject pyo = pyo let to_pyobject x = x let __init__ () = let callable = Py.Module.get (import_module ()) \"Plotter\" in let kwargs = filter_opt [] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let set_title t ~title () = let callable = Py.Object.find_attr_string t \"set_title\" in let kwargs = filter_opt [ Some (\"title\", Py.String.of_string title) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let plot t ~x ~y ?color () = let callable = Py.Object.find_attr_string t \"plot\" in let kwargs = filter_opt [ Some (\"x\", Py.List.of_list_map Py.Float.of_float x); Some (\"y\", Py.List.of_list_map Py.Float.of_float y); (match color with | Some color -> Some (\"color\", Py.String.of_string color) | None -> None); ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs let save t ~filename () = let callable = Py.Object.find_attr_string t \"save\" in let kwargs = filter_opt [ Some (\"filename\", Py.String.of_string filename) ] in ignore @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Run pyml_bindgen"},{"location":"matplotlib/#set-up-the-dune-project","text":"Now we need a dune file and a driver to run our plotting code. Save these two files in the same directory in which you generated the lib.ml file. dune (executable (name run) (libraries pyml)) run.ml open Lib let () = Py.initialize () let x = [ 1.; 2.; 3.; 4.; 5. ] let y = [ 1.; 1.5; 2.; 3.; 3.5 ] let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Silly Plot\" () (* See how [color] is optional? *) let () = Plotter.plot plotter ~x ~y () let () = Plotter.save plotter ~filename:\"silly_plot.png\" () let plotter = Plotter.__init__ () let () = Plotter.set_title plotter ~title:\"Orange Plot\" () (* Here, we pass the [color] argument. *) let () = Plotter.plot plotter ~x ~y ~color:\"tab:orange\" () let () = Plotter.save plotter ~filename:\"orange_plot.png\" () And now, go ahead and run that. $ dune exec ./run.exe If all goes well, you should see a couple of PNG files there. Here's what they should look like. The first plot, with default colors: And the orange plot: Pretty cool, right?","title":"Set up the Dune project"},{"location":"matplotlib/#wrap-up","text":"Okay, so this was kind of a goofy example. It's a little artificial, as you probably would want to just bind to matplotlib directly, but to keep things simple, we just used a simple class that binds some matplotlib functionality. It did show you some new stuff, though, and we got to make some cute plots! \ud83d\udcc8 \ud83d\udcca","title":"Wrap up"},{"location":"names/","text":"Function & Argument Names You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned above are not allowed. Argument names that start with any of the types mentioned above are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) This will probably be fixed at some point.... Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse.","title":"Function & Argument Names"},{"location":"names/#function-argument-names","text":"You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned above are not allowed. Argument names that start with any of the types mentioned above are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) This will probably be fixed at some point.... Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse.","title":"Function &amp; Argument Names"},{"location":"of-pyobject/","text":"Converting pyobjects to OCaml Types With pyml_bindgen , you are generally want to set up a binding from a single Python class to a single OCaml module. E.g., class Foo: def __init__(self, x) self.x = x def add1(self): self.x += 1 would have a corresponding module something like this module Foo : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val x : t -> int val add1 : t -> unit -> unit end = struct type t = Pytypes.pyobject let of_pyobject x = x let to_pyobject x = x let add1 t () = end In the above example, we don't bother checking the Python-land type of the pyobject . All OCaml compiler knows at compile time is that we are taking a Pytypes.pyobject type and getting back a Foo.t . Depending on how that pyobject was actually created elsewhere in the code, it might not actually be an instance of the Foo class. In this case, when you go to call the Foo.say_hi function in your OCaml code, you will get a runtime error. Let me give you an example. let i = Py.Int.of_int 1 assert let foo = Foo.of_pyobject i let _ = Foo.say_hi foo () (* ERROR! *) You'll get an exception: Exception: E (<class 'AttributeError'>, 'int' object has no attribute 'add1') . Checking pyobjects at module boundaries While you could remove the of_pyobject function from the interface, you are often going to need it outside the module. For example, you may have a Python class Foo that has a method which returns an object of class Bar . In your OCaml code you'd need to call the Bar.of_pyobject method from inside the Foo module. Basically, you would like to have an of_pyobject that actually checks that the underlying Python type is what the module expects. I.e., you only want to create a Foo.t if the pyobject is a Foo object in Python-land. You can address this problem in the typical OCaml way (e.g., by returning t option or t Or_error.t instead of t ) in pyml_bindgen as well. Let's see what I mean. pyml_bindgen automatically generates of_pyobject and to_pyobject functions for you (in fact, you shouldn't provide those yourself). You can generate three kinds of_pyobject function with pyml_bindgen : No checking: val of_pyobject : Pytypes.pyobject -> t option returning: val of_pyobject : Pytypes.pyobject -> t option Base Or_error.t returning: val of_pyobject : Pytypes.pyobject -> t Or_error.t You can choose between the three with the --of-pyo-ret-type option. Here is the section from the man page: -r OF_PYO_RET_TYPE, --of-pyo-ret-type=OF_PYO_RET_TYPE (absent=option) Return type of the of_pyobject function. OF_PYO_RET_TYPE must be one of `no_check', `option' or `or_error'. While the option and Or_error.t let you avoid a lot of potential runtime problems, they will force you to deal with potential errors each time of_pyobject is called, and in code generated by pyml_bindgen you may not realize that it is being called! Say that you generated both Person and Job modules with the --of-pyo-ret-type=option command line option. Then both of these modules will have of_pyobject functions that return t option rather than just t . Note: For now, you can only generate one of these module signatures at a time with pyml_bindgen . To combine them, you'll have to run it multiple times and then combine manually. Here is an example of code that won't work. module rec Person : sig type t val of_pyobject : Pytypes.pyobject -> t option (* Oops! *) val get_job : t -> unit -> Job.t ... end = struct ... end and Job : sig type t val of_pyobject : Pytypes.pyobject -> t option ... end = struct ... end When pyml_bindgen sees a function that ends in a custom type (a module type like Job.t , Person.t , or whatever), the generated code will call that type's of_pyobject function to convert it to the correct OCaml type. So, for Person.get_job it will generate a function that calls Job.of_pyobject somewhere in the get_job implementation. Of course, Job.of_pyobject returns Job.t option and not Job.t . But in the Person.get_job signature, we've specified that get_job returns Job.t and NOT Job.t option . Now, pyml_bindgen will happily generate this implementation for you, but when you try to actually compile it, you will get an error about the return type of get_job implementation not matching the expected signature. So what do you do? Well, you have to remember that the --of-pyo-ret-type=option and --of-pyo-ret-type=or_error flags will essentially poison all generated functions that manipulate other auto-generated modules. Specifically, for this example, you can't write val get_job : t -> unit -> Job.t . Instead, you have to write val get_job : t -> unit -> Job.t option . Just so that it's clear, the reason is because Job.of_pyobject returns Job.t option , and the generated implementation of Person.get_job will call Job.of_pyobject somewhere in its body.) Wrap-up You have to be aware of the return types of the of_pyobject functions you're generating with pyml_bindgen . If you use option or Or_error.t , you have to remember to adjust your value specifications accordingly!","title":"Converting `pyobjects` to OCaml types"},{"location":"of-pyobject/#converting-pyobjects-to-ocaml-types","text":"With pyml_bindgen , you are generally want to set up a binding from a single Python class to a single OCaml module. E.g., class Foo: def __init__(self, x) self.x = x def add1(self): self.x += 1 would have a corresponding module something like this module Foo : sig type t val of_pyobject : Pytypes.pyobject -> t val to_pyobject : t -> Pytypes.pyobject val x : t -> int val add1 : t -> unit -> unit end = struct type t = Pytypes.pyobject let of_pyobject x = x let to_pyobject x = x let add1 t () = end In the above example, we don't bother checking the Python-land type of the pyobject . All OCaml compiler knows at compile time is that we are taking a Pytypes.pyobject type and getting back a Foo.t . Depending on how that pyobject was actually created elsewhere in the code, it might not actually be an instance of the Foo class. In this case, when you go to call the Foo.say_hi function in your OCaml code, you will get a runtime error. Let me give you an example. let i = Py.Int.of_int 1 assert let foo = Foo.of_pyobject i let _ = Foo.say_hi foo () (* ERROR! *) You'll get an exception: Exception: E (<class 'AttributeError'>, 'int' object has no attribute 'add1') .","title":"Converting pyobjects to OCaml Types"},{"location":"of-pyobject/#checking-pyobjects-at-module-boundaries","text":"While you could remove the of_pyobject function from the interface, you are often going to need it outside the module. For example, you may have a Python class Foo that has a method which returns an object of class Bar . In your OCaml code you'd need to call the Bar.of_pyobject method from inside the Foo module. Basically, you would like to have an of_pyobject that actually checks that the underlying Python type is what the module expects. I.e., you only want to create a Foo.t if the pyobject is a Foo object in Python-land. You can address this problem in the typical OCaml way (e.g., by returning t option or t Or_error.t instead of t ) in pyml_bindgen as well. Let's see what I mean. pyml_bindgen automatically generates of_pyobject and to_pyobject functions for you (in fact, you shouldn't provide those yourself). You can generate three kinds of_pyobject function with pyml_bindgen : No checking: val of_pyobject : Pytypes.pyobject -> t option returning: val of_pyobject : Pytypes.pyobject -> t option Base Or_error.t returning: val of_pyobject : Pytypes.pyobject -> t Or_error.t You can choose between the three with the --of-pyo-ret-type option. Here is the section from the man page: -r OF_PYO_RET_TYPE, --of-pyo-ret-type=OF_PYO_RET_TYPE (absent=option) Return type of the of_pyobject function. OF_PYO_RET_TYPE must be one of `no_check', `option' or `or_error'. While the option and Or_error.t let you avoid a lot of potential runtime problems, they will force you to deal with potential errors each time of_pyobject is called, and in code generated by pyml_bindgen you may not realize that it is being called! Say that you generated both Person and Job modules with the --of-pyo-ret-type=option command line option. Then both of these modules will have of_pyobject functions that return t option rather than just t . Note: For now, you can only generate one of these module signatures at a time with pyml_bindgen . To combine them, you'll have to run it multiple times and then combine manually. Here is an example of code that won't work. module rec Person : sig type t val of_pyobject : Pytypes.pyobject -> t option (* Oops! *) val get_job : t -> unit -> Job.t ... end = struct ... end and Job : sig type t val of_pyobject : Pytypes.pyobject -> t option ... end = struct ... end When pyml_bindgen sees a function that ends in a custom type (a module type like Job.t , Person.t , or whatever), the generated code will call that type's of_pyobject function to convert it to the correct OCaml type. So, for Person.get_job it will generate a function that calls Job.of_pyobject somewhere in the get_job implementation. Of course, Job.of_pyobject returns Job.t option and not Job.t . But in the Person.get_job signature, we've specified that get_job returns Job.t and NOT Job.t option . Now, pyml_bindgen will happily generate this implementation for you, but when you try to actually compile it, you will get an error about the return type of get_job implementation not matching the expected signature. So what do you do? Well, you have to remember that the --of-pyo-ret-type=option and --of-pyo-ret-type=or_error flags will essentially poison all generated functions that manipulate other auto-generated modules. Specifically, for this example, you can't write val get_job : t -> unit -> Job.t . Instead, you have to write val get_job : t -> unit -> Job.t option . Just so that it's clear, the reason is because Job.of_pyobject returns Job.t option , and the generated implementation of Person.get_job will call Job.of_pyobject somewhere in its body.)","title":"Checking pyobjects at module boundaries"},{"location":"of-pyobject/#wrap-up","text":"You have to be aware of the return types of the of_pyobject functions you're generating with pyml_bindgen . If you use option or Or_error.t , you have to remember to adjust your value specifications accordingly!","title":"Wrap-up"},{"location":"static-methods/","text":"Class & Static Methods Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c Rules The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Examples val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int Binding __init__ TODO","title":"Class & Static Methods"},{"location":"static-methods/#class-static-methods","text":"Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Class &amp; Static Methods"},{"location":"static-methods/#rules","text":"The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above .","title":"Rules"},{"location":"static-methods/#examples","text":"val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int","title":"Examples"},{"location":"static-methods/#binding-__init__","text":"TODO","title":"Binding __init__"},{"location":"todo/","text":"To do Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"todo/#to-do","text":"Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"tuples/","text":"Handling Tuples Tuples are sort of weird....As of now, pyml_bindgen can't handle tuples directly :( For now what you need to do is to create a little helper module that \"wraps\" the tuple you need to pass in to Python or return from Python. (Or just write the binding by hand...) Say you need to get an int * string tuple in and out of Python. You should make a module something like this: module rec Tuple_int_string : sig type t val make : int -> string -> t val to_pyobject : t -> Pytypes.pyobject val of_pyobject : Pytypes.pyobject -> t val print_endline : t -> unit end = struct type t = int * string let make i s = (i, s) let to_pyobject (i, s) = Py.Tuple.of_tuple2 (Py.Int.of_int i, Py.String.of_string s) let of_pyobject pyo = let i, s = Py.Tuple.to_tuple2 pyo in (Py.Int.to_int i, Py.String.to_string s) let print_endline (i, s) = print_endline @@ string_of_int i ^ \" \" ^ s end Then you can put that with the code that pyml_bindgen generates for whatever class you're actually trying to bind. Perhaps something like this... module rec Tuple_int_string : sig ... end = struct ... end and My_cool_thing : sig ... val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t ... end (You get the idea.) In the val specs that you write, just refer to the Tuple_int_string module like any other: val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t The key here is to have a module that has working to_pyobject and of_pyobject functions. If these two functions know how to properly get your type/module into and out of Python-land, then it should work :) There is a Cram test here that illustrates this idea. Just note that some of the bash stuff in the run.t file is to automate it, but you'd probably do that part by hand. *Note: At some point, I will work up a full example with tuples and other types that you can't yet deal with directly in pyml_bindgen .","title":"Handling Tuples"},{"location":"tuples/#handling-tuples","text":"Tuples are sort of weird....As of now, pyml_bindgen can't handle tuples directly :( For now what you need to do is to create a little helper module that \"wraps\" the tuple you need to pass in to Python or return from Python. (Or just write the binding by hand...) Say you need to get an int * string tuple in and out of Python. You should make a module something like this: module rec Tuple_int_string : sig type t val make : int -> string -> t val to_pyobject : t -> Pytypes.pyobject val of_pyobject : Pytypes.pyobject -> t val print_endline : t -> unit end = struct type t = int * string let make i s = (i, s) let to_pyobject (i, s) = Py.Tuple.of_tuple2 (Py.Int.of_int i, Py.String.of_string s) let of_pyobject pyo = let i, s = Py.Tuple.to_tuple2 pyo in (Py.Int.to_int i, Py.String.to_string s) let print_endline (i, s) = print_endline @@ string_of_int i ^ \" \" ^ s end Then you can put that with the code that pyml_bindgen generates for whatever class you're actually trying to bind. Perhaps something like this... module rec Tuple_int_string : sig ... end = struct ... end and My_cool_thing : sig ... val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t ... end (You get the idea.) In the val specs that you write, just refer to the Tuple_int_string module like any other: val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t The key here is to have a module that has working to_pyobject and of_pyobject functions. If these two functions know how to properly get your type/module into and out of Python-land, then it should work :) There is a Cram test here that illustrates this idea. Just note that some of the bash stuff in the run.t file is to automate it, but you'd probably do that part by hand. *Note: At some point, I will work up a full example with tuples and other types that you can't yet deal with directly in pyml_bindgen .","title":"Handling Tuples"},{"location":"types/","text":"Types Not all OCaml types are allowed. There are a lot of tests that exercise the rules here. Function arguments For function arguments, you can use float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Apple_pie.t ) Arrays of any of the above types Lists of any of the above types Seq.t of any of the above types 'a option , 'a option array , 'a option list , 'a option Seq.t Return types For return types, you can use all of the above types plus unit , and 'a Or_error.t for types 'a other than unit . However, you cannot use unit array , unit list , or unit Seq.t . This is because I haven't decided the best way to handle unit and None (that's Python's None ) quite yet! Nesting Note: currently, you're not allowed to have nested array , list , Seq.t , or Or_error.t . If you need them, you will have to bind those functions by hand :) E.g., 'a array list will fail. You are allowed to nest 'a option in arrays, lists, and Seq.t s (e.g., 'a option list ); however, this will not work with Or_error.t . Dictionaries TODO mention the hack for Python dictionaries... Tuples Tuples are a little weird in pyml_bindgen . If you need to pass or return tuples to Python functions, see here .","title":"Types"},{"location":"types/#types","text":"Not all OCaml types are allowed. There are a lot of tests that exercise the rules here.","title":"Types"},{"location":"types/#function-arguments","text":"For function arguments, you can use float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Apple_pie.t ) Arrays of any of the above types Lists of any of the above types Seq.t of any of the above types 'a option , 'a option array , 'a option list , 'a option Seq.t","title":"Function arguments"},{"location":"types/#return-types","text":"For return types, you can use all of the above types plus unit , and 'a Or_error.t for types 'a other than unit . However, you cannot use unit array , unit list , or unit Seq.t . This is because I haven't decided the best way to handle unit and None (that's Python's None ) quite yet!","title":"Return types"},{"location":"types/#nesting","text":"Note: currently, you're not allowed to have nested array , list , Seq.t , or Or_error.t . If you need them, you will have to bind those functions by hand :) E.g., 'a array list will fail. You are allowed to nest 'a option in arrays, lists, and Seq.t s (e.g., 'a option list ); however, this will not work with Or_error.t .","title":"Nesting"},{"location":"types/#dictionaries","text":"TODO mention the hack for Python dictionaries...","title":"Dictionaries"},{"location":"types/#tuples","text":"Tuples are a little weird in pyml_bindgen . If you need to pass or return tuples to Python functions, see here .","title":"Tuples"}]}