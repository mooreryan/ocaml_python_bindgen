{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OCaml-Python Bindings Generator Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96 How to get started Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, you can either peruse the rules for writing value specifications that pyml_bindgen can understand, or check out more examples . If you have any questions or issues, please let me know about it on GitHub! Installing pyml_bindgen is a Dune project, so you should be able to clone the repository and build it with dune as long as you have the proper dependencies installed \ud83e\udd1e $ git clone https://github.com/mooreryan/pyml_bindgen.git $ cd pyml_bindgen $ opam install . --deps-only --with-doc --with-test $ dune test && dune build --profile=release && dune install $ pyml_bindgen --help ... help screen should show up ... Quick start pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml $ ocamlformat --enable-outside-detected-project lib.ml And here's the output of the ocamlformat command. let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read. License Software Copyright (c) 2021 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms. Documentation Copyright (c) 2021 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"pyml_bindgen"},{"location":"#ocaml-python-bindings-generator","text":"Generate Python bindings with pyml directly from OCaml value specifications. While you could write all your Python bindings by hand, it can be tedious and it gets old real quick. While pyml_bindgen can't yet auto-generate all the bindings you may need, it can definitely take care of a lot of the tedious and repetitive work you need to do when writing bindings for a big Python library!! \ud83d\udc96","title":"OCaml-Python Bindings Generator"},{"location":"#how-to-get-started","text":"Getting started with a new package or library and going through lots of docs can be frustrating. Here's the order I would suggest you look at these docs Read the installing and quick start sections of this page. Then read through the getting started tutorial. If you only read one page in the docs, make it this one! It explains most of what you need to know to get started with a simple example, while not getting bogged down in too much details. Next, you can either peruse the rules for writing value specifications that pyml_bindgen can understand, or check out more examples . If you have any questions or issues, please let me know about it on GitHub!","title":"How to get started"},{"location":"#installing","text":"pyml_bindgen is a Dune project, so you should be able to clone the repository and build it with dune as long as you have the proper dependencies installed \ud83e\udd1e $ git clone https://github.com/mooreryan/pyml_bindgen.git $ cd pyml_bindgen $ opam install . --deps-only --with-doc --with-test $ dune test && dune build --profile=release && dune install $ pyml_bindgen --help ... help screen should show up ...","title":"Installing"},{"location":"#quick-start","text":"pyml_bindgen is a CLI program that generates OCaml modules that bind Python classes via pyml . Here's a small example. Take a Python class, Thing . (Put it in a file called thing.py ...this means the Python module will be called thing .) class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y Now, look at your Python class and decide how you would like to use this class on the OCaml side. For now, we will just do a direct translation, keeping in mind the rules for writing value specs that pyml_bindgen can process. Maybe something like this. (Put it in a file called val_specs.txt .) val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int Finally, to generate the OCaml code, run the pyml_bindgen program. There are a couple of options you can choose, but let's just keep it simple for now. $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing > lib.ml $ ocamlformat --enable-outside-detected-project lib.ml And here's the output of the ocamlformat command. let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Check out the examples for more info about using and running pyml_bindgen . Then, check out the rules that you have to follow when writing value specifications that pyml_bindgen can read.","title":"Quick start"},{"location":"#license","text":"","title":"License"},{"location":"#software","text":"Copyright (c) 2021 Ryan M. Moore. Licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms.","title":"Software"},{"location":"#documentation","text":"Copyright (c) 2021 Ryan M. Moore. This documentation is licensed under a Creative Commons Attribution 4.0 International License .","title":"Documentation"},{"location":"attributes/","text":"Attributes & Properties Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a Rules The first and only function argument must be t . The return type can be any of the types mentioned above . Examples val x : t -> int val name : t -> string val price : t -> float","title":"Attributes & Properties"},{"location":"attributes/#attributes-properties","text":"Value specifications that take a single argument t will be interpreted as bindings to Python attributes or properties. Value specs for attributes and properties look like this: val f : t -> 'a","title":"Attributes &amp; Properties"},{"location":"attributes/#rules","text":"The first and only function argument must be t . The return type can be any of the types mentioned above .","title":"Rules"},{"location":"attributes/#examples","text":"val x : t -> int val name : t -> string val price : t -> float","title":"Examples"},{"location":"getting-started/","text":"Getting Started To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do the obvious thing write OCaml functions with the same names as the Python methods. You also need to use named (or optional) arguments. Binding constructors __init__ in Python constructs an instance of the class. While you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit . See here for more about why that is. Binding instance methods Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods. Binding static methods TODO: we only have tests for static methods, but class methods should be the same...check it! Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods. Binding instance attributes Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int One thing to keep in mind is that many Python function can take values of different types. We could bind x with an OCaml function that returns float . In cases where you're binding polymorphic python functions, let the rest of your API guide you on how you'd like to type everything. You can find more info on binding attributes in the attributes & properties section of the manual. Running pyml_bindgen Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly. For more info on pyml_bindgen options, see here . I ran lib.ml through ocamlformat so it's easier to read here, but of course, that's optional! $ ocamlformat lib.ml --enable-outside-detected-project And here's the output: let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int val sub : a:int -> b:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs let sub ~a ~b () = let class_ = Py.Module.get (import_module ()) \"Thing\" in let callable = Py.Object.find_attr_string class_ \"sub\" in let kwargs = filter_opt [ Some (\"a\", Py.Int.of_int a); Some (\"b\", Py.Int.of_int b) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end Using the generated module While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"To get started, let's revisit the example on the main page. This time, we will add a bit more to it. class Thing: def __init__(self, x): self.x = x def add(self, y): return self.x + y @staticmethod def sub(a, b): return a - b Save that in a file called thing.py . Just to make it clear, the Python module will be called thing , and the class in that module will be called Thing . Of course, we can name the OCaml module whatever we'd like, but why not name it Thing as well? While there are many ways you may want to write a binding for this class by-hand, pyml_bindgen forces you to do the obvious thing write OCaml functions with the same names as the Python methods. You also need to use named (or optional) arguments.","title":"Getting Started"},{"location":"getting-started/#binding-constructors","text":"__init__ in Python constructs an instance of the class. While you don't usually call __init__ directly, it is the way to instantiate classes when using pyml_bindgen . In val specs for pyml_bindgen , we use t to represent the OCaml module/Python class you're working on, and so, __init__ will return t . Python: def __init__(self, x): self.x = x OCaml: val __init__ : x:int -> unit -> t The other thing to note is that the last argument to method bindings must be unit . See here for more about why that is.","title":"Binding constructors"},{"location":"getting-started/#binding-instance-methods","text":"Instance methods are those that are called on instances of a Python class. In Python, instance methods take self (a reference to the object) as the first argument. So when binding instance methods with pyml_bindgen , the first argument must be t . The middle arguments should be named (or optional) and the final argument should be unit . Python: def add(self, y): return self.x + y OCaml: val add : t -> y:int -> unit -> int The instance methods section has more info on binding instance methods.","title":"Binding instance methods"},{"location":"getting-started/#binding-static-methods","text":"TODO: we only have tests for static methods, but class methods should be the same...check it! Python static methods are methods associated with a class, but that don't have access to class-wide state, or access to object state. You can still call them on either instances of a class or the class itself, but it won't have access to any of that internal state. Binding these with pyml_bindgen is pretty much like writing val specs for regular OCaml functions, except that each argument must be named (or optional) and the final argument must be unit . Python: @staticmethod def sub(a, b): return a - b OCaml: val sub : a:int -> b:int -> unit -> int See class & static methods for more info on binding static methods.","title":"Binding static methods"},{"location":"getting-started/#binding-instance-attributes","text":"Note: Currently, you can only bind attribute getters automatically. If you need setters as well, you'll have to write them by hand :) In the __init__ function of the Thing class, you can see that we set an instance variable/attribute x on instance creation. You can expose functions in your OCaml interface to access Python instance attributes, by providing a function with the same name as the attribute that takes t . val x : t -> int One thing to keep in mind is that many Python function can take values of different types. We could bind x with an OCaml function that returns float . In cases where you're binding polymorphic python functions, let the rest of your API guide you on how you'd like to type everything. You can find more info on binding attributes in the attributes & properties section of the manual.","title":"Binding instance attributes"},{"location":"getting-started/#running-pyml_bindgen","text":"Let's put all those val specs into a file called val_specs.txt . Then, we can run pyml_bindgen ! $ pyml_bindgen val_specs.txt thing Thing --caml-module=Thing --of-pyo-ret-type=no_check > lib.ml val_specs.txt is the file with value specifications thing is the python module (this time we got it from the name of our Python script Thing is the name of the Python class we're binding The --caml-module=Thing option tells pyml_bindgen to generate a module and signature called Thing based on the val specs you provided. If you leave this flag out, pyml_bindgen will just generate the implementations that you can manually add where you want. The --of-pyo-ret-type=no_check argument tells pyml_bindgen not to check that the Python class is what you expect it to be. If there is some weird bug in the Python, or a mistake in your bindings, you'll get a runtime error! The other options for this are option and or_error , which will check that Python classes are correct, but you'll have to deal with the possibility of error explicitly. For more info on pyml_bindgen options, see here . I ran lib.ml through ocamlformat so it's easier to read here, but of course, that's optional! $ ocamlformat lib.ml --enable-outside-detected-project And here's the output: let filter_opt l = List.filter_map Fun.id l let import_module () = Py.Import.import_module \"thing\" module Thing : sig type t val of_pyobject : Pytypes.pyobject -> t option val to_pyobject : t -> Pytypes.pyobject val __init__ : x:int -> unit -> t val x : t -> int val add : t -> y:int -> unit -> int val sub : a:int -> b:int -> unit -> int end = struct type t = Pytypes.pyobject let is_instance pyo = let py_class = Py.Module.get (import_module ()) \"Thing\" in Py.Object.is_instance pyo py_class let of_pyobject pyo = if is_instance pyo then Some pyo else None let to_pyobject x = x let __init__ ~x () = let callable = Py.Module.get (import_module ()) \"Thing\" in let kwargs = filter_opt [ Some (\"x\", Py.Int.of_int x) ] in of_pyobject @@ Py.Callable.to_function_with_keywords callable [||] kwargs let x t = Py.Int.to_int @@ Py.Object.find_attr_string t \"x\" let add t ~y () = let callable = Py.Object.find_attr_string t \"add\" in let kwargs = filter_opt [ Some (\"y\", Py.Int.of_int y) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs let sub ~a ~b () = let class_ = Py.Module.get (import_module ()) \"Thing\" in let callable = Py.Object.find_attr_string class_ \"sub\" in let kwargs = filter_opt [ Some (\"a\", Py.Int.of_int a); Some (\"b\", Py.Int.of_int b) ] in Py.Int.to_int @@ Py.Callable.to_function_with_keywords callable [||] kwargs end","title":"Running pyml_bindgen"},{"location":"getting-started/#using-the-generated-module","text":"While you're here, let's go ahead and make a quick executable that uses the generated module. Add the following files to your working directory. dune (executable (name run) (libraries pyml)) run.ml (* Remember that we named the generated file lib.ml. *) open Lib (* Don't forget to initialize Python! *) let () = Py.initialize () let thing = Thing.__init__ ~x:10 () let () = print_endline @@ string_of_int @@ Thing.x thing let () = print_endline @@ string_of_int @@ Thing.add thing ~y:20 () let () = print_endline @@ string_of_int @@ Thing.sub ~a:1 ~b:2 () Now run it! $ dune exec ./run.exe 10 30 -1","title":"Using the generated module"},{"location":"gotchas-bugs/","text":"Gotchas & Known Bugs You currently can't bind \"no argument\" functions like this: val bad_fun : unit -> t Or_error.t . It's a bug that will get fixed at some point.","title":"Gotchas & Known Bugs"},{"location":"gotchas-bugs/#gotchas-known-bugs","text":"You currently can't bind \"no argument\" functions like this: val bad_fun : unit -> t Or_error.t . It's a bug that will get fixed at some point.","title":"Gotchas &amp; Known Bugs"},{"location":"instance-methods/","text":"Instance Methods Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c Rules The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future, but for now, that's how it works :)","title":"Instance Methods"},{"location":"instance-methods/#instance-methods","text":"Value specs for instance methods look like this: val f : t -> a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Instance Methods"},{"location":"instance-methods/#rules","text":"The first argument must be t . The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Note on the final unit argument...I require all arguments that bind to Python method arguments be named or optional. Python will often have optional named arguments at the end of a function's arguments. In OCaml, these can't be erased unless you have a unit argument that comes after. So, to keep the APIs all looking similar, I decided that all instance and static methods would end in a final unit argument. This may change in the future, but for now, that's how it works :)","title":"Rules"},{"location":"names/","text":"Function & Argument Names You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned above are not allowed. Argument names that start with any of the types mentioned above are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) This will probably be fixed at some point.... Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse.","title":"Function & Argument Names"},{"location":"names/#function-argument-names","text":"You can't pick just any old name for your functions and arguments :) The main thing to remember is in addition to being valid OCaml names, they must also be valid python names . This is because we pass the function name and argument names \"as-is\" to Python. In addition to that, there are a couple other things to keep in mind. Argument names that match any of the types mentioned above are not allowed. Argument names that start with any of the types mentioned above are not allowed. (E.g., val foo : t -> int_thing:string -> unit -> float will fail.) Argument names that end with any of the above types are actually okay. You probably shouldn't name them like this but it works. Really, it's just an artifact of the parsing :) This will probably be fixed at some point.... Function names and arguments can start with underscores (e.g., __init__ ) but they cannot be all underscores. E.g., val ____ : ... will not parse.","title":"Function &amp; Argument Names"},{"location":"no-functions/","text":"You can only bind methods, not functions Currently, you can only bind to functions within Python classes (a.k.a., Python methods). At some point, I will change it so you can also bind Python functions that aren't associated with a class. Here's what I mean. A function that isn't associated with a class currently cannot be bound with pyml_bindgen . # Can't bind this def foo(x, y): return x + y But that same function associated with a class, can be bound by pyml_bindgen . # Can bind this class Apple: @staticmethod def foo(x, y): return x + y Let me just be clear that pyml can bind this function just fine, only, you would need to write this binding by hand.","title":"You can only bind methods, not functions"},{"location":"no-functions/#you-can-only-bind-methods-not-functions","text":"Currently, you can only bind to functions within Python classes (a.k.a., Python methods). At some point, I will change it so you can also bind Python functions that aren't associated with a class. Here's what I mean. A function that isn't associated with a class currently cannot be bound with pyml_bindgen . # Can't bind this def foo(x, y): return x + y But that same function associated with a class, can be bound by pyml_bindgen . # Can bind this class Apple: @staticmethod def foo(x, y): return x + y Let me just be clear that pyml can bind this function just fine, only, you would need to write this binding by hand.","title":"You can only bind methods, not functions"},{"location":"static-methods/","text":"Class & Static Methods Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c Rules The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above . Examples val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int Binding __init__ TODO","title":"Class & Static Methods"},{"location":"static-methods/#class-static-methods","text":"Value specs for class/static methods look like this: val f : a:'a -> ?b:'b -> ... -> unit -> 'c","title":"Class &amp; Static Methods"},{"location":"static-methods/#rules","text":"The final function argument (penultimate type expression) must be unit . The return type can be any of the types mentioned above . The remaining function arguments must either be named or optional. The types of these arguments can be any of the types mentioned above .","title":"Rules"},{"location":"static-methods/#examples","text":"val add_item : fruit:string -> price:float -> unit -> unit val subtract : x:int -> ?y:int -> unit -> int","title":"Examples"},{"location":"static-methods/#binding-__init__","text":"TODO","title":"Binding __init__"},{"location":"todo/","text":"To do Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"todo/#to-do","text":"Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the pyml_bindgen repository.","title":"To do"},{"location":"tuples/","text":"Handling Tuples Tuples are sort of weird....As of now, pyml_bindgen can't handle tuples directly :( For now what you need to do is to create a little helper module that \"wraps\" the tuple you need to pass in to Python or return from Python. Say you need to get an int * string tuple in and out of Python. You should make a module something like this: module rec Tuple_int_string : sig type t val make : int -> string -> t val to_pyobject : t -> Pytypes.pyobject val of_pyobject : Pytypes.pyobject -> t val print_endline : t -> unit end = struct type t = int * string let make i s = (i, s) let to_pyobject (i, s) = Py.Tuple.of_tuple2 (Py.Int.of_int i, Py.String.of_string s) let of_pyobject pyo = let i, s = Py.Tuple.to_tuple2 pyo in (Py.Int.to_int i, Py.String.to_string s) let print_endline (i, s) = print_endline @@ string_of_int i ^ \" \" ^ s end Then you can put that with the code that pyml_bindgen generates for whatever class you're actually trying to bind. In the val specs that you write, just refer to the Tuple_int_string module like any other: val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t As long as you properly wrote the to_pyobject and of_pyobject , then it should work :) There is a Cram test here that illustrates this idea. Just note that some of the bash stuff in the run.t file is to automate it, but you'd probably do that part by hand.","title":"Handling Tuples"},{"location":"tuples/#handling-tuples","text":"Tuples are sort of weird....As of now, pyml_bindgen can't handle tuples directly :( For now what you need to do is to create a little helper module that \"wraps\" the tuple you need to pass in to Python or return from Python. Say you need to get an int * string tuple in and out of Python. You should make a module something like this: module rec Tuple_int_string : sig type t val make : int -> string -> t val to_pyobject : t -> Pytypes.pyobject val of_pyobject : Pytypes.pyobject -> t val print_endline : t -> unit end = struct type t = int * string let make i s = (i, s) let to_pyobject (i, s) = Py.Tuple.of_tuple2 (Py.Int.of_int i, Py.String.of_string s) let of_pyobject pyo = let i, s = Py.Tuple.to_tuple2 pyo in (Py.Int.to_int i, Py.String.to_string s) let print_endline (i, s) = print_endline @@ string_of_int i ^ \" \" ^ s end Then you can put that with the code that pyml_bindgen generates for whatever class you're actually trying to bind. In the val specs that you write, just refer to the Tuple_int_string module like any other: val foo : x:Tuple_int_string.t -> unit -> Tuple_int_string.t As long as you properly wrote the to_pyobject and of_pyobject , then it should work :) There is a Cram test here that illustrates this idea. Just note that some of the bash stuff in the run.t file is to automate it, but you'd probably do that part by hand.","title":"Handling Tuples"},{"location":"types/","text":"Types Not all OCaml types are allowed. For function arguments, you can use: int float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Apple_pie.t ) Lists of any of the above types Seq.t of any of the above types For return types, you can use all of the above types plus unit . You can also return 'a list and 'a Seq.t as well. Additionally, you can return 'a option and 'a Or_error.t for certain types 'a . Currently, you can only have t option , t Or_error.t , <custom> option , and <custom> Or_error.t . I actually have no idea why I did this...I almost certainly will change it :) Oh, and one more thing about unit ...you can't use it with list and Seq.t . This is because I haven't decided the best way to handle unit and None (that's Python's None ) quite yet! There are a lot of tests that exercise the rules here. Note: currently, you're not allowed to have nested list , Seq.t , option , or Or_error.t . If you need them, you will have to bind those functions by hand :) Dictionaries TODO mention the hack for Python dictionaries... Tuples Tuples are a little weird in pyml_bindgen . If you need to pass or return tuples to Python functions, see here .","title":"Types"},{"location":"types/#types","text":"Not all OCaml types are allowed. For function arguments, you can use: int float string bool t (i.e., the main type of the current module) Other module types (e.g., Span.t , Doc.t , Apple_pie.t ) Lists of any of the above types Seq.t of any of the above types For return types, you can use all of the above types plus unit . You can also return 'a list and 'a Seq.t as well. Additionally, you can return 'a option and 'a Or_error.t for certain types 'a . Currently, you can only have t option , t Or_error.t , <custom> option , and <custom> Or_error.t . I actually have no idea why I did this...I almost certainly will change it :) Oh, and one more thing about unit ...you can't use it with list and Seq.t . This is because I haven't decided the best way to handle unit and None (that's Python's None ) quite yet! There are a lot of tests that exercise the rules here. Note: currently, you're not allowed to have nested list , Seq.t , option , or Or_error.t . If you need them, you will have to bind those functions by hand :)","title":"Types"},{"location":"types/#dictionaries","text":"TODO mention the hack for Python dictionaries...","title":"Dictionaries"},{"location":"types/#tuples","text":"Tuples are a little weird in pyml_bindgen . If you need to pass or return tuples to Python functions, see here .","title":"Tuples"}]}